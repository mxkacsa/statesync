package gen

const rulesTemplate = `// Code generated by logicgen v2. DO NOT EDIT.
package {{.PackageName}}

import (
{{range $import, $_ := .Imports}}	"{{$import}}"
{{end}})

// RulesEngine executes all defined rules
type RulesEngine struct {
	state *{{.StateType}}
	tick uint64
	lastTick time.Time
	views map[string]interface{}
}

// NewRulesEngine creates a new rules engine
func NewRulesEngine(state *{{.StateType}}) *RulesEngine {
	return &RulesEngine{
		state: state,
		views: make(map[string]interface{}),
	}
}

// Context provides runtime context for rule evaluation
type Context struct {
	Tick      uint64
	DeltaTime time.Duration
	Event     *Event
	Params    map[string]interface{}
	views     map[string]interface{}
}

// Event represents a game event
type Event struct {
	Name   string
	Params map[string]interface{}
}

// Resolve resolves a path reference
func (ctx *Context) Resolve(path string) interface{} {
	// Implementation depends on path format
	return nil
}

// ResolvePath resolves a path reference
func (ctx *Context) ResolvePath(path string) interface{} {
	return ctx.Resolve(path)
}

// Emit emits an event
func (ctx *Context) Emit(name string, payload map[string]interface{}) {
	// Implementation depends on event system
}

// Tick processes one game tick
func (r *RulesEngine) Tick(ctx context.Context) error {
	now := time.Now()
	dt := now.Sub(r.lastTick)
	r.lastTick = now
	r.tick++

	evalCtx := &Context{
		Tick:      r.tick,
		DeltaTime: dt,
		Params:    make(map[string]interface{}),
		views:     r.views,
	}

	return r.processTick(ctx, evalCtx)
}

// TickWithDelta processes one tick with explicit delta time
func (r *RulesEngine) TickWithDelta(ctx context.Context, dt time.Duration) error {
	r.tick++
	evalCtx := &Context{
		Tick:      r.tick,
		DeltaTime: dt,
		Params:    make(map[string]interface{}),
		views:     r.views,
	}
	return r.processTick(ctx, evalCtx)
}

// HandleEvent processes an event
func (r *RulesEngine) HandleEvent(ctx context.Context, event *Event) error {
	evalCtx := &Context{
		Tick:      r.tick,
		DeltaTime: 0,
		Event:     event,
		Params:    make(map[string]interface{}),
		views:     r.views,
	}
	if event.Params != nil {
		for k, v := range event.Params {
			evalCtx.Params[k] = v
		}
	}
	return r.processEvent(ctx, evalCtx)
}

// processTick executes all tick-based rules
func (r *RulesEngine) processTick(ctx context.Context, evalCtx *Context) error {
	state := r.state
	views := r.views
	_ = state
	_ = views
{{range .Rules}}
	// Rule: {{.Name}}
	if err := r.rule_{{.FuncName}}(ctx, evalCtx); err != nil {
		return fmt.Errorf("rule {{.Name}}: %w", err)
	}
{{end}}
	return nil
}

// processEvent executes all event-based rules
func (r *RulesEngine) processEvent(ctx context.Context, evalCtx *Context) error {
	state := r.state
	views := r.views
	_ = state
	_ = views
{{range .Rules}}
	if err := r.rule_{{.FuncName}}(ctx, evalCtx); err != nil {
		return fmt.Errorf("rule {{.Name}}: %w", err)
	}
{{end}}
	return nil
}

{{range .Rules}}
// rule_{{.FuncName}} executes the "{{.Name}}" rule
{{if .Description}}// {{.Description}}{{end}}
func (r *RulesEngine) rule_{{.FuncName}}(ctx context.Context, evalCtx *Context) error {
	state := r.state
	views := r.views
	_ = state
	_ = views

	// Trigger check
	{{.TriggerCode}}

	// Select entities
	{{if .HasSelector}}{{.SelectorCode}}{{else}}entities := []interface{}{state}{{end}}
	_ = entities

	// Compute views
	{{if .HasViews}}{{.ViewsCode}}{{end}}

	// Apply effects
	{{.EffectsCode}}

	return nil
}
{{end}}

// Helper functions

func haversineDistance(from, to interface{}) float64 {
	// Implement haversine distance calculation
	return 0
}

func moveTowards(current, target interface{}, distance float64) interface{} {
	// Implement move towards calculation
	return current
}
`

const helperFunctionsTemplate = `
// haversineDistance calculates the distance between two GPS points in meters
func haversineDistance(from, to GeoPoint) float64 {
	const earthRadiusMeters = 6371000.0
	const degreesToRadians = 0.017453292519943295

	lat1 := from.Lat * degreesToRadians
	lat2 := to.Lat * degreesToRadians
	deltaLat := (to.Lat - from.Lat) * degreesToRadians
	deltaLon := (to.Lon - from.Lon) * degreesToRadians

	a := math.Sin(deltaLat/2)*math.Sin(deltaLat/2) +
		math.Cos(lat1)*math.Cos(lat2)*
			math.Sin(deltaLon/2)*math.Sin(deltaLon/2)
	c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))

	return earthRadiusMeters * c
}

// moveTowards moves a point towards a target by a distance
func moveTowards(current, target GeoPoint, distance float64) GeoPoint {
	totalDist := haversineDistance(current, target)
	if totalDist <= 0 || distance <= 0 {
		return current
	}
	if distance >= totalDist {
		return target
	}

	ratio := distance / totalDist
	return GeoPoint{
		Lat: current.Lat + (target.Lat-current.Lat)*ratio,
		Lon: current.Lon + (target.Lon-current.Lon)*ratio,
	}
}
`
