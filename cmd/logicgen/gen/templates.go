package gen

const rulesTemplate = `// Code generated by logicgen v2. DO NOT EDIT.
package {{.PackageName}}

import (
{{range $import, $_ := .Imports}}	"{{$import}}"
{{end}})

// RulesEngine executes all defined rules
type RulesEngine struct {
	state      *{{.StateType}}
	tick       uint64
	lastTick   time.Time
	views      map[string]interface{}
	eventRules map[string][]func(context.Context, *Context) error
	evalCtx    *Context // Reusable context to reduce allocations
}

// NewRulesEngine creates a new rules engine
func NewRulesEngine(state *{{.StateType}}) *RulesEngine {
	r := &RulesEngine{
		state:      state,
		views:      make(map[string]interface{}),
		eventRules: make(map[string][]func(context.Context, *Context) error),
		evalCtx: &Context{
			Params: make(map[string]interface{}),
		},
	}
	r.evalCtx.views = r.views
	r.registerEventRules()
	return r
}

// registerEventRules registers event-based rules for fast lookup
func (r *RulesEngine) registerEventRules() {
{{range .Rules}}{{if eq .TriggerType "event"}}	r.eventRules["{{.EventName}}"] = append(r.eventRules["{{.EventName}}"], r.rule_{{.FuncName}})
{{end}}{{end}}}

// Context provides runtime context for rule evaluation
type Context struct {
	Tick      uint64
	DeltaTime time.Duration
	Event     *Event
	Params    map[string]interface{}
	views     map[string]interface{}
}

// Event represents a game event
type Event struct {
	Name   string
	Params map[string]interface{}
}

// Resolve resolves a path reference
func (ctx *Context) Resolve(path string) interface{} {
	// Implementation depends on path format
	return nil
}

// ResolvePath resolves a path reference
func (ctx *Context) ResolvePath(path string) interface{} {
	return ctx.Resolve(path)
}

// Emit emits an event
func (ctx *Context) Emit(name string, payload map[string]interface{}) {
	// Implementation depends on event system
}

// Tick processes one game tick
func (r *RulesEngine) Tick(ctx context.Context) error {
	now := time.Now()
	dt := now.Sub(r.lastTick)
	r.lastTick = now
	r.tick++

	// Reuse context, clear params
	r.evalCtx.Tick = r.tick
	r.evalCtx.DeltaTime = dt
	r.evalCtx.Event = nil
	clear(r.evalCtx.Params)

	return r.processTick(ctx, r.evalCtx)
}

// TickWithDelta processes one tick with explicit delta time
func (r *RulesEngine) TickWithDelta(ctx context.Context, dt time.Duration) error {
	r.tick++

	// Reuse context, clear params
	r.evalCtx.Tick = r.tick
	r.evalCtx.DeltaTime = dt
	r.evalCtx.Event = nil
	clear(r.evalCtx.Params)

	return r.processTick(ctx, r.evalCtx)
}

// HandleEvent processes an event
func (r *RulesEngine) HandleEvent(ctx context.Context, event *Event) error {
	// Reuse context, clear params
	r.evalCtx.Tick = r.tick
	r.evalCtx.DeltaTime = 0
	r.evalCtx.Event = event
	clear(r.evalCtx.Params)

	if event.Params != nil {
		for k, v := range event.Params {
			r.evalCtx.Params[k] = v
		}
	}
	return r.processEvent(ctx, r.evalCtx)
}

// processTick executes all tick-based rules
func (r *RulesEngine) processTick(ctx context.Context, evalCtx *Context) error {
	state := r.state
	views := r.views
	_ = state
	_ = views
{{range .Rules}}{{if ne .TriggerType "event"}}
	// Rule: {{.Name}}
	if err := r.rule_{{.FuncName}}(ctx, evalCtx); err != nil {
		return fmt.Errorf("rule {{.Name}}: %w", err)
	}
{{end}}{{end}}
	return nil
}

// processEvent executes only event-based rules matching the event
func (r *RulesEngine) processEvent(ctx context.Context, evalCtx *Context) error {
	if evalCtx.Event == nil {
		return nil
	}

	rules, ok := r.eventRules[evalCtx.Event.Name]
	if !ok {
		return nil // No rules for this event
	}

	for _, rule := range rules {
		if err := rule(ctx, evalCtx); err != nil {
			return err
		}
	}
	return nil
}

{{range .Rules}}
// rule_{{.FuncName}} executes the "{{.Name}}" rule
{{if .Description}}// {{.Description}}{{end}}
func (r *RulesEngine) rule_{{.FuncName}}(ctx context.Context, evalCtx *Context) error {
	state := r.state
	views := r.views
	_ = state
	_ = views

	// Trigger check
	{{.TriggerCode}}

	// Select entities
	{{if .HasSelector}}{{.SelectorCode}}{{else}}entities := []interface{}{state}{{end}}
	_ = entities

	// Compute views
	{{if .HasViews}}{{.ViewsCode}}{{end}}

	// Apply effects
	{{.EffectsCode}}

	return nil
}
{{end}}

// GeoPoint represents a GPS coordinate
type GeoPoint struct {
	Lat float64
	Lon float64
}

// haversineDistance calculates the distance between two GPS points in meters
func haversineDistance(from, to GeoPoint) float64 {
	const earthRadiusMeters = 6371000.0
	const degreesToRadians = math.Pi / 180.0

	lat1 := from.Lat * degreesToRadians
	lat2 := to.Lat * degreesToRadians
	deltaLat := (to.Lat - from.Lat) * degreesToRadians
	deltaLon := (to.Lon - from.Lon) * degreesToRadians

	a := math.Sin(deltaLat/2)*math.Sin(deltaLat/2) +
		math.Cos(lat1)*math.Cos(lat2)*
			math.Sin(deltaLon/2)*math.Sin(deltaLon/2)
	c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))

	return earthRadiusMeters * c
}

// normalizeLon normalizes longitude to [-180, 180] range
func normalizeLon(lon float64) float64 {
	for lon > 180 {
		lon -= 360
	}
	for lon < -180 {
		lon += 360
	}
	return lon
}

// moveTowards moves a point towards a target by a distance in meters
func moveTowards(current, target GeoPoint, distance float64) GeoPoint {
	totalDist := haversineDistance(current, target)
	if totalDist <= 0 || distance <= 0 {
		return current
	}
	if distance >= totalDist {
		return target
	}

	ratio := distance / totalDist

	// Handle longitude wrap-around at +/-180
	deltaLon := target.Lon - current.Lon
	if deltaLon > 180 {
		deltaLon -= 360
	} else if deltaLon < -180 {
		deltaLon += 360
	}

	return GeoPoint{
		Lat: current.Lat + (target.Lat-current.Lat)*ratio,
		Lon: normalizeLon(current.Lon + deltaLon*ratio),
	}
}
`

const helperFunctionsTemplate = `
// haversineDistance calculates the distance between two GPS points in meters
func haversineDistance(from, to GeoPoint) float64 {
	const earthRadiusMeters = 6371000.0
	const degreesToRadians = 0.017453292519943295

	lat1 := from.Lat * degreesToRadians
	lat2 := to.Lat * degreesToRadians
	deltaLat := (to.Lat - from.Lat) * degreesToRadians
	deltaLon := (to.Lon - from.Lon) * degreesToRadians

	a := math.Sin(deltaLat/2)*math.Sin(deltaLat/2) +
		math.Cos(lat1)*math.Cos(lat2)*
			math.Sin(deltaLon/2)*math.Sin(deltaLon/2)
	c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))

	return earthRadiusMeters * c
}

// moveTowards moves a point towards a target by a distance
func moveTowards(current, target GeoPoint, distance float64) GeoPoint {
	totalDist := haversineDistance(current, target)
	if totalDist <= 0 || distance <= 0 {
		return current
	}
	if distance >= totalDist {
		return target
	}

	ratio := distance / totalDist
	return GeoPoint{
		Lat: current.Lat + (target.Lat-current.Lat)*ratio,
		Lon: current.Lon + (target.Lon-current.Lon)*ratio,
	}
}
`
