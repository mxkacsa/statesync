package main

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"
	"text/template"
)

// encoderMethod returns the Encoder.WriteXxx method name for a type
func encoderMethod(typ string) string {
	switch typ {
	case "int8":
		return "WriteInt8"
	case "int16":
		return "WriteInt16"
	case "int32":
		return "WriteInt32"
	case "int", "int64":
		return "WriteInt64"
	case "uint8", "byte":
		return "WriteUint8"
	case "uint16":
		return "WriteUint16"
	case "uint32":
		return "WriteUint32"
	case "uint", "uint64":
		return "WriteUint64"
	case "float32":
		return "WriteFloat32"
	case "float64":
		return "WriteFloat64"
	case "string":
		return "WriteString"
	case "bool":
		return "WriteBool"
	case "[]byte":
		return "WriteBytes"
	default:
		return "" // Complex types need special handling
	}
}

// GenerateGo generates Go code from a schema file
func GenerateGo(schema *SchemaFile) ([]byte, error) {
	tmpl, err := template.New("go").Funcs(template.FuncMap{
		"goType":        GoType,
		"fieldType":     FieldTypeEnum,
		"parseType":     ParseType,
		"isPrimitive":   IsPrimitive,
		"lower":         strings.ToLower,
		"sub":           func(a, b int) int { return a - b },
		"hasViewFilter": func(f *FieldDef) bool { return len(f.Views) > 0 },
		"encoderMethod": encoderMethod,
	}).Parse(goTemplate)
	if err != nil {
		return nil, fmt.Errorf("template parse error: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, schema); err != nil {
		return nil, fmt.Errorf("template execute error: %w", err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted with error info
		return nil, fmt.Errorf("format error: %w\n%s", err, buf.String())
	}

	return formatted, nil
}

const goTemplate = `// Code generated by schemagen. DO NOT EDIT.

package {{.Package}}

import (
	"sync"

	"github.com/mxkacsa/statesync"
)

{{range $t := .Types}}
// {{$t.Name}} is a tracked state type
type {{$t.Name}} struct {
	mu      sync.RWMutex
	changes *statesync.ChangeSet
	schema  *statesync.Schema

	{{range $t.Fields}}
	{{lower .Name}} {{goType .Type}}
	{{- end}}
}

// New{{$t.Name}} creates a new {{$t.Name}}
func New{{$t.Name}}() *{{$t.Name}} {
	return &{{$t.Name}}{
		changes: statesync.NewChangeSet(),
		schema:  {{$t.Name}}Schema(),
	}
}

// {{$t.Name}}Schema returns the schema for {{$t.Name}}
func {{$t.Name}}Schema() *statesync.Schema {
	return statesync.NewSchemaBuilder("{{$t.Name}}").
		WithID({{$t.ID}}).
		{{- range $i, $f := $t.Fields}}
		{{- $pt := parseType $f.Type}}
		{{- if $pt.IsArray}}
		{{- if $f.Key}}
		ArrayByKey("{{$f.Name}}", statesync.{{fieldType $pt.ElemType}}, {{if not (isPrimitive $pt.ElemType)}}{{$pt.ElemType}}Schema(){{else}}nil{{end}}, "{{$f.Key}}").
		{{- else}}
		Array("{{$f.Name}}", statesync.{{fieldType $pt.ElemType}}, {{if not (isPrimitive $pt.ElemType)}}{{$pt.ElemType}}Schema(){{else}}nil{{end}}).
		{{- end}}
		{{- else if $pt.IsMap}}
		Map("{{$f.Name}}", statesync.{{fieldType $pt.ElemType}}, {{if not (isPrimitive $pt.ElemType)}}{{$pt.ElemType}}Schema(){{else}}nil{{end}}).
		{{- else}}
		{{- $ft := fieldType $f.Type}}
		{{- if eq $ft "TypeInt8"}}Int8{{else if eq $ft "TypeInt16"}}Int16{{else if eq $ft "TypeInt32"}}Int32{{else if eq $ft "TypeInt64"}}Int64{{else if eq $ft "TypeUint8"}}Uint8{{else if eq $ft "TypeUint16"}}Uint16{{else if eq $ft "TypeUint32"}}Uint32{{else if eq $ft "TypeUint64"}}Uint64{{else if eq $ft "TypeFloat32"}}Float32{{else if eq $ft "TypeFloat64"}}Float64{{else if eq $ft "TypeString"}}String{{else if eq $ft "TypeBool"}}Bool{{else if eq $ft "TypeBytes"}}Bytes{{else}}Struct{{end}}("{{$f.Name}}"{{if eq $ft "TypeStruct"}}, {{$f.Type}}Schema(){{end}}).
		{{- end}}
		{{- end}}
		Build()
}

// Trackable implementation

func (t *{{$t.Name}}) Schema() *statesync.Schema     { return t.schema }
func (t *{{$t.Name}}) Changes() *statesync.ChangeSet { return t.changes }
func (t *{{$t.Name}}) ClearChanges()                 { t.changes.Clear() }
func (t *{{$t.Name}}) MarkAllDirty()                 { t.changes.MarkAll({{sub (len $t.Fields) 1}}) }

func (t *{{$t.Name}}) GetFieldValue(index uint8) interface{} {
	t.mu.RLock()
	defer t.mu.RUnlock()
	switch index {
	{{- range $i, $f := $t.Fields}}
	case {{$i}}:
		{{- $pt := parseType $f.Type}}
		{{- if or (eq $f.Type "int") (eq $f.Type "uint")}}
		return int64(t.{{lower $f.Name}})
		{{- else}}
		return t.{{lower $f.Name}}
		{{- end}}
	{{- end}}
	}
	return nil
}

// FastEncoder implementation - zero allocation encoding

func (t *{{$t.Name}}) EncodeChangesTo(e *statesync.Encoder) {
	t.mu.RLock()
	defer t.mu.RUnlock()

	// Count and write number of changes
	changes := t.changes
	count := 0
	{{- range $i, $f := $t.Fields}}
	if changes.IsFieldDirty({{$i}}) { count++ }
	{{- end}}
	e.WriteChangeCount(count)

	// Encode each changed field directly (no interface{} boxing)
	{{- range $i, $f := $t.Fields}}
	{{- $em := encoderMethod $f.Type}}
	if changes.IsFieldDirty({{$i}}) {
		e.WriteFieldHeader({{$i}}, statesync.OpReplace)
		{{- if $em}}
		e.{{$em}}(t.{{lower $f.Name}})
		{{- else}}
		// Complex type - TODO: handle arrays/maps/structs
		{{- end}}
	}
	{{- end}}
}

func (t *{{$t.Name}}) EncodeAllTo(e *statesync.Encoder) {
	t.mu.RLock()
	defer t.mu.RUnlock()

	// Encode all fields directly (no interface{} boxing)
	{{- range $i, $f := $t.Fields}}
	{{- $em := encoderMethod $f.Type}}
	{{- if $em}}
	e.{{$em}}(t.{{lower $f.Name}})
	{{- else}}
	// Complex type field {{$f.Name}} - TODO: handle arrays/maps/structs
	{{- end}}
	{{- end}}
}

// Getters and Setters
{{range $i, $f := $t.Fields}}
{{- $pt := parseType $f.Type}}
{{- $goT := goType $f.Type}}
{{- $lower := lower $f.Name}}

// {{$f.Name}} returns the current value
func (t *{{$t.Name}}) {{$f.Name}}() {{$goT}} {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.{{$lower}}
}

{{if not $pt.IsArray}}{{if not $pt.IsMap}}
// Set{{$f.Name}} sets the value and marks it as changed
func (t *{{$t.Name}}) Set{{$f.Name}}(v {{$goT}}) {
	t.mu.Lock()
	defer t.mu.Unlock()
	{{if or (eq $f.Type "string") (isPrimitive $f.Type)}}
	if t.{{$lower}} != v {
		t.{{$lower}} = v
		t.changes.Mark({{$i}}, statesync.OpReplace)
	}
	{{else}}
	t.{{$lower}} = v
	t.changes.Mark({{$i}}, statesync.OpReplace)
	{{end}}
}
{{end}}{{end}}

{{if $pt.IsArray}}
// Set{{$f.Name}} replaces the entire slice
func (t *{{$t.Name}}) Set{{$f.Name}}(v {{$goT}}) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.{{$lower}} = v
	t.changes.Mark({{$i}}, statesync.OpReplace)
}

// Append{{$f.Name}} adds an element to the slice
func (t *{{$t.Name}}) Append{{$f.Name}}(v {{$pt.ElemType}}) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.{{$lower}} = append(t.{{$lower}}, v)
	arr := t.changes.GetOrCreateArray({{$i}})
	arr.MarkAdd(len(t.{{$lower}})-1, v)
}

// Remove{{$f.Name}}At removes an element at index
func (t *{{$t.Name}}) Remove{{$f.Name}}At(index int) {
	t.mu.Lock()
	defer t.mu.Unlock()
	if index >= 0 && index < len(t.{{$lower}}) {
		t.{{$lower}} = append(t.{{$lower}}[:index], t.{{$lower}}[index+1:]...)
		arr := t.changes.GetOrCreateArray({{$i}})
		arr.MarkRemove(index)
	}
}

// Update{{$f.Name}}At updates an element at index
func (t *{{$t.Name}}) Update{{$f.Name}}At(index int, v {{$pt.ElemType}}) {
	t.mu.Lock()
	defer t.mu.Unlock()
	if index >= 0 && index < len(t.{{$lower}}) {
		t.{{$lower}}[index] = v
		arr := t.changes.GetOrCreateArray({{$i}})
		arr.MarkReplace(index, v)
	}
}

// {{$f.Name}}Len returns the length of the slice
func (t *{{$t.Name}}) {{$f.Name}}Len() int {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return len(t.{{$lower}})
}

// {{$f.Name}}At returns the element at index
func (t *{{$t.Name}}) {{$f.Name}}At(index int) {{$pt.ElemType}} {
	t.mu.RLock()
	defer t.mu.RUnlock()
	if index >= 0 && index < len(t.{{$lower}}) {
		return t.{{$lower}}[index]
	}
	var zero {{$pt.ElemType}}
	return zero
}
{{end}}

{{if $pt.IsMap}}
// Set{{$f.Name}} replaces the entire map
func (t *{{$t.Name}}) Set{{$f.Name}}(v {{$goT}}) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.{{$lower}} = v
	t.changes.Mark({{$i}}, statesync.OpReplace)
}

// Set{{$f.Name}}Key sets a map key
func (t *{{$t.Name}}) Set{{$f.Name}}Key(key {{$pt.KeyType}}, v {{$pt.ElemType}}) {
	t.mu.Lock()
	defer t.mu.Unlock()
	if t.{{$lower}} == nil {
		t.{{$lower}} = make({{$goT}})
	}
	_, existed := t.{{$lower}}[key]
	t.{{$lower}}[key] = v
	m := t.changes.GetOrCreateMap({{$i}})
	if existed {
		m.MarkReplace(key, v)
	} else {
		m.MarkAdd(key, v)
	}
}

// Delete{{$f.Name}}Key deletes a map key
func (t *{{$t.Name}}) Delete{{$f.Name}}Key(key {{$pt.KeyType}}) {
	t.mu.Lock()
	defer t.mu.Unlock()
	if t.{{$lower}} != nil {
		if _, ok := t.{{$lower}}[key]; ok {
			delete(t.{{$lower}}, key)
			m := t.changes.GetOrCreateMap({{$i}})
			m.MarkRemove(key)
		}
	}
}

// {{$f.Name}}Get returns the value for a key
func (t *{{$t.Name}}) {{$f.Name}}Get(key {{$pt.KeyType}}) ({{$pt.ElemType}}, bool) {
	t.mu.RLock()
	defer t.mu.RUnlock()
	if t.{{$lower}} == nil {
		var zero {{$pt.ElemType}}
		return zero, false
	}
	v, ok := t.{{$lower}}[key]
	return v, ok
}
{{end}}
{{end}}
{{end}}
`
