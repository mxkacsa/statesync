package main

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"
	"text/template"
)

// encoderMethod returns the Encoder.WriteXxx method name for a type
func encoderMethod(typ string) string {
	switch typ {
	case "int8":
		return "WriteInt8"
	case "int16":
		return "WriteInt16"
	case "int32":
		return "WriteInt32"
	case "int", "int64":
		return "WriteInt64"
	case "uint8", "byte":
		return "WriteUint8"
	case "uint16":
		return "WriteUint16"
	case "uint32":
		return "WriteUint32"
	case "uint", "uint64":
		return "WriteUint64"
	case "float32":
		return "WriteFloat32"
	case "float64":
		return "WriteFloat64"
	case "string":
		return "WriteString"
	case "bool":
		return "WriteBool"
	case "[]byte":
		return "WriteBytes"
	default:
		return "" // Complex types need special handling
	}
}

// goDefaultValue generates Go code for the default value of a field
func goDefaultValue(f *FieldDef) string {
	pt := ParseType(f.Type)

	// Array or map without explicit default -> nil
	if pt.IsArray || pt.IsMap {
		return "nil"
	}

	// No default source -> zero value
	if f.DefaultSource == "" || f.DefaultSource == DefaultNone {
		return goZeroValue(f.Type)
	}

	// Config reference: @default(config:GameConfig.Speed)
	if f.DefaultSource == DefaultConfig {
		parts := strings.Split(f.DefaultValue, ".")
		if len(parts) == 2 {
			return fmt.Sprintf("Get%s().%s", parts[0], parts[1])
		}
		return f.DefaultValue
	}

	// Literal value
	switch pt.BaseType {
	case "string":
		return fmt.Sprintf("%q", f.DefaultValue)
	case "bool":
		return f.DefaultValue
	default:
		return f.DefaultValue
	}
}

// goZeroValue returns the Go zero value for a type
func goZeroValue(t string) string {
	pt := ParseType(t)

	if pt.IsArray || pt.IsMap {
		return "nil"
	}

	switch pt.BaseType {
	case "string":
		return `""`
	case "bool":
		return "false"
	case "int8", "int16", "int32", "int64", "int",
		"uint8", "uint16", "uint32", "uint64", "uint":
		return "0"
	case "float32", "float64":
		return "0.0"
	default:
		return "nil"
	}
}

// hasConfigDefaults checks if any field uses config defaults
func hasConfigDefaults(schema *SchemaFile) bool {
	for _, t := range schema.Types {
		for _, f := range t.Fields {
			if f.DefaultSource == DefaultConfig {
				return true
			}
		}
	}
	return false
}

// getRootSchemas returns only root schemas
func getRootSchemas(schema *SchemaFile) []*TypeDef {
	var roots []*TypeDef
	for _, t := range schema.Types {
		if t.Role == RoleRoot {
			roots = append(roots, t)
		}
	}
	return roots
}

// GenerateGo generates Go code from a schema file
func GenerateGo(schema *SchemaFile) ([]byte, error) {
	tmpl, err := template.New("go").Funcs(template.FuncMap{
		"goType":            GoType,
		"fieldType":         FieldTypeEnum,
		"parseType":         ParseType,
		"isPrimitive":       IsPrimitive,
		"lower":             strings.ToLower,
		"sub":               func(a, b int) int { return a - b },
		"hasViewFilter":     func(f *FieldDef) bool { return len(f.Views) > 0 },
		"encoderMethod":     encoderMethod,
		"goDefaultValue":    goDefaultValue,
		"goZeroValue":       goZeroValue,
		"hasConfigDefaults": hasConfigDefaults,
		"getRootSchemas":    getRootSchemas,
		"isRoot":            func(t *TypeDef) bool { return t.Role == RoleRoot },
		"isActiveByDefault": func(t *TypeDef) bool { return t.DefaultState == "active" },
	}).Parse(goTemplate)
	if err != nil {
		return nil, fmt.Errorf("template parse error: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, schema); err != nil {
		return nil, fmt.Errorf("template execute error: %w", err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted with error info
		return nil, fmt.Errorf("format error: %w\n%s", err, buf.String())
	}

	return formatted, nil
}

const goTemplate = `// Code generated by schemagen. DO NOT EDIT.

package {{.Package}}

import (
	"fmt"
	"sync"

	"github.com/mxkacsa/statesync"
)

{{range $t := .Types}}
// {{$t.Name}} is a tracked state type
type {{$t.Name}} struct {
	mu      sync.RWMutex
	changes *statesync.ChangeSet
	schema  *statesync.Schema

	{{range $t.Fields}}
	{{lower .Name}} {{goType .Type}}
	{{- end}}
}

// New{{$t.Name}} creates a new {{$t.Name}} with default values
func New{{$t.Name}}() *{{$t.Name}} {
	t := &{{$t.Name}}{
		changes: statesync.NewChangeSet(),
		schema:  {{$t.Name}}Schema(),
	}
	t.ResetToDefaults()
	return t
}

// ResetToDefaults resets all fields to their default values
func (t *{{$t.Name}}) ResetToDefaults() {
	t.mu.Lock()
	defer t.mu.Unlock()
	{{- range $i, $f := $t.Fields}}
	t.{{lower $f.Name}} = {{goDefaultValue $f}}
	{{- end}}
	t.changes.MarkAll({{sub (len $t.Fields) 1}})
}

// {{$t.Name}}Schema returns the schema for {{$t.Name}}
func {{$t.Name}}Schema() *statesync.Schema {
	return statesync.NewSchemaBuilder("{{$t.Name}}").
		WithID({{$t.ID}}).
		{{- range $i, $f := $t.Fields}}
		{{- $pt := parseType $f.Type}}
		{{- if $pt.IsArray}}
		{{- if $f.Key}}
		ArrayByKey("{{$f.Name}}", statesync.{{fieldType $pt.ElemType}}, {{if not (isPrimitive $pt.ElemType)}}{{$pt.ElemType}}Schema(){{else}}nil{{end}}, "{{$f.Key}}").
		{{- else}}
		Array("{{$f.Name}}", statesync.{{fieldType $pt.ElemType}}, {{if not (isPrimitive $pt.ElemType)}}{{$pt.ElemType}}Schema(){{else}}nil{{end}}).
		{{- end}}
		{{- else if $pt.IsMap}}
		Map("{{$f.Name}}", statesync.{{fieldType $pt.ElemType}}, {{if not (isPrimitive $pt.ElemType)}}{{$pt.ElemType}}Schema(){{else}}nil{{end}}).
		{{- else}}
		{{- $ft := fieldType $f.Type}}
		{{- if eq $ft "TypeInt8"}}Int8{{else if eq $ft "TypeInt16"}}Int16{{else if eq $ft "TypeInt32"}}Int32{{else if eq $ft "TypeInt64"}}Int64{{else if eq $ft "TypeUint8"}}Uint8{{else if eq $ft "TypeUint16"}}Uint16{{else if eq $ft "TypeUint32"}}Uint32{{else if eq $ft "TypeUint64"}}Uint64{{else if eq $ft "TypeFloat32"}}Float32{{else if eq $ft "TypeFloat64"}}Float64{{else if eq $ft "TypeString"}}String{{else if eq $ft "TypeBool"}}Bool{{else if eq $ft "TypeBytes"}}Bytes{{else}}Struct{{end}}("{{$f.Name}}"{{if eq $ft "TypeStruct"}}, {{$f.Type}}Schema(){{end}}).
		{{- end}}
		{{- end}}
		Build()
}

// Trackable implementation

func (t *{{$t.Name}}) Schema() *statesync.Schema     { return t.schema }
func (t *{{$t.Name}}) Changes() *statesync.ChangeSet { return t.changes }
func (t *{{$t.Name}}) ClearChanges()                 { t.changes.Clear() }
func (t *{{$t.Name}}) MarkAllDirty()                 { t.changes.MarkAll({{sub (len $t.Fields) 1}}) }

func (t *{{$t.Name}}) GetFieldValue(index uint8) interface{} {
	t.mu.RLock()
	defer t.mu.RUnlock()
	switch index {
	{{- range $i, $f := $t.Fields}}
	case {{$i}}:
		{{- $pt := parseType $f.Type}}
		{{- if or (eq $f.Type "int") (eq $f.Type "uint")}}
		return int64(t.{{lower $f.Name}})
		{{- else}}
		return t.{{lower $f.Name}}
		{{- end}}
	{{- end}}
	}
	return nil
}

// FastEncoder implementation - zero allocation encoding

func (t *{{$t.Name}}) EncodeChangesTo(e *statesync.Encoder) {
	t.mu.RLock()
	defer t.mu.RUnlock()

	// Count and write number of changes
	changes := t.changes
	count := 0
	{{- range $i, $f := $t.Fields}}
	if changes.IsFieldDirty({{$i}}) { count++ }
	{{- end}}
	e.WriteChangeCount(count)

	// Encode each changed field directly (no interface{} boxing)
	{{- range $i, $f := $t.Fields}}
	{{- $em := encoderMethod $f.Type}}
	if changes.IsFieldDirty({{$i}}) {
		e.WriteFieldHeader({{$i}}, statesync.OpReplace)
		{{- if $em}}
		e.{{$em}}(t.{{lower $f.Name}})
		{{- else}}
		// Complex type - TODO: handle arrays/maps/structs
		{{- end}}
	}
	{{- end}}
}

func (t *{{$t.Name}}) EncodeAllTo(e *statesync.Encoder) {
	t.mu.RLock()
	defer t.mu.RUnlock()

	// Encode all fields directly (no interface{} boxing)
	{{- range $i, $f := $t.Fields}}
	{{- $em := encoderMethod $f.Type}}
	{{- if $em}}
	e.{{$em}}(t.{{lower $f.Name}})
	{{- else}}
	// Complex type field {{$f.Name}} - TODO: handle arrays/maps/structs
	{{- end}}
	{{- end}}
}

// Getters and Setters
{{range $i, $f := $t.Fields}}
{{- $pt := parseType $f.Type}}
{{- $goT := goType $f.Type}}
{{- $lower := lower $f.Name}}

// {{$f.Name}} returns the current value
func (t *{{$t.Name}}) {{$f.Name}}() {{$goT}} {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.{{$lower}}
}

{{if not $pt.IsArray}}{{if not $pt.IsMap}}
// Set{{$f.Name}} sets the value and marks it as changed
func (t *{{$t.Name}}) Set{{$f.Name}}(v {{$goT}}) {
	t.mu.Lock()
	defer t.mu.Unlock()
	{{if or (eq $f.Type "string") (isPrimitive $f.Type)}}
	if t.{{$lower}} != v {
		t.{{$lower}} = v
		t.changes.Mark({{$i}}, statesync.OpReplace)
	}
	{{else}}
	t.{{$lower}} = v
	t.changes.Mark({{$i}}, statesync.OpReplace)
	{{end}}
}
{{end}}{{end}}

{{if $pt.IsArray}}
// Set{{$f.Name}} replaces the entire slice
func (t *{{$t.Name}}) Set{{$f.Name}}(v {{$goT}}) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.{{$lower}} = v
	t.changes.Mark({{$i}}, statesync.OpReplace)
}

// Append{{$f.Name}} adds an element to the slice
func (t *{{$t.Name}}) Append{{$f.Name}}(v {{$pt.ElemType}}) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.{{$lower}} = append(t.{{$lower}}, v)
	arr := t.changes.GetOrCreateArray({{$i}})
	arr.MarkAdd(len(t.{{$lower}})-1, v)
}

// Remove{{$f.Name}}At removes an element at index
func (t *{{$t.Name}}) Remove{{$f.Name}}At(index int) {
	t.mu.Lock()
	defer t.mu.Unlock()
	if index >= 0 && index < len(t.{{$lower}}) {
		t.{{$lower}} = append(t.{{$lower}}[:index], t.{{$lower}}[index+1:]...)
		arr := t.changes.GetOrCreateArray({{$i}})
		arr.MarkRemove(index)
	}
}

// Update{{$f.Name}}At updates an element at index
func (t *{{$t.Name}}) Update{{$f.Name}}At(index int, v {{$pt.ElemType}}) {
	t.mu.Lock()
	defer t.mu.Unlock()
	if index >= 0 && index < len(t.{{$lower}}) {
		t.{{$lower}}[index] = v
		arr := t.changes.GetOrCreateArray({{$i}})
		arr.MarkReplace(index, v)
	}
}

// {{$f.Name}}Len returns the length of the slice
func (t *{{$t.Name}}) {{$f.Name}}Len() int {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return len(t.{{$lower}})
}

// {{$f.Name}}At returns the element at index
func (t *{{$t.Name}}) {{$f.Name}}At(index int) {{$pt.ElemType}} {
	t.mu.RLock()
	defer t.mu.RUnlock()
	if index >= 0 && index < len(t.{{$lower}}) {
		return t.{{$lower}}[index]
	}
	var zero {{$pt.ElemType}}
	return zero
}
{{end}}

{{if $pt.IsMap}}
// Set{{$f.Name}} replaces the entire map
func (t *{{$t.Name}}) Set{{$f.Name}}(v {{$goT}}) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.{{$lower}} = v
	t.changes.Mark({{$i}}, statesync.OpReplace)
}

// Set{{$f.Name}}Key sets a map key
func (t *{{$t.Name}}) Set{{$f.Name}}Key(key {{$pt.KeyType}}, v {{$pt.ElemType}}) {
	t.mu.Lock()
	defer t.mu.Unlock()
	if t.{{$lower}} == nil {
		t.{{$lower}} = make({{$goT}})
	}
	_, existed := t.{{$lower}}[key]
	t.{{$lower}}[key] = v
	m := t.changes.GetOrCreateMap({{$i}})
	if existed {
		m.MarkReplace(key, v)
	} else {
		m.MarkAdd(key, v)
	}
}

// Delete{{$f.Name}}Key deletes a map key
func (t *{{$t.Name}}) Delete{{$f.Name}}Key(key {{$pt.KeyType}}) {
	t.mu.Lock()
	defer t.mu.Unlock()
	if t.{{$lower}} != nil {
		if _, ok := t.{{$lower}}[key]; ok {
			delete(t.{{$lower}}, key)
			m := t.changes.GetOrCreateMap({{$i}})
			m.MarkRemove(key)
		}
	}
}

// {{$f.Name}}Get returns the value for a key
func (t *{{$t.Name}}) {{$f.Name}}Get(key {{$pt.KeyType}}) ({{$pt.ElemType}}, bool) {
	t.mu.RLock()
	defer t.mu.RUnlock()
	if t.{{$lower}} == nil {
		var zero {{$pt.ElemType}}
		return zero, false
	}
	v, ok := t.{{$lower}}[key]
	return v, ok
}
{{end}}
{{end}}
{{end}}

// ==================================================
// Schema Registry - manages root schemas activation
// ==================================================

// SchemaRegistry manages activation state of root schemas
type SchemaRegistry struct {
	mu       sync.RWMutex
	active   map[string]bool
	schemas  map[string]func() interface{} // Factory functions
	instances map[string]interface{}       // Active instances
}

var (
	schemaRegistryInstance *SchemaRegistry
	schemaRegistryOnce     sync.Once
)

// GetSchemaRegistry returns the singleton schema registry
func GetSchemaRegistry() *SchemaRegistry {
	schemaRegistryOnce.Do(func() {
		schemaRegistryInstance = &SchemaRegistry{
			active:    make(map[string]bool),
			schemas:   make(map[string]func() interface{}),
			instances: make(map[string]interface{}),
		}
		// Register all root schemas
		{{- range $t := .Types}}
		{{- if isRoot $t}}
		schemaRegistryInstance.schemas["{{$t.Name}}"] = func() interface{} { return New{{$t.Name}}() }
		schemaRegistryInstance.active["{{$t.Name}}"] = {{isActiveByDefault $t}}
		{{- if isActiveByDefault $t}}
		schemaRegistryInstance.instances["{{$t.Name}}"] = New{{$t.Name}}()
		{{- end}}
		{{- end}}
		{{- end}}
	})
	return schemaRegistryInstance
}

// IsActive returns true if the schema is currently active
func (r *SchemaRegistry) IsActive(name string) bool {
	r.mu.RLock()
	defer r.mu.RUnlock()
	return r.active[name]
}

// Activate activates a schema (resets to defaults)
func (r *SchemaRegistry) Activate(name string) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	factory, ok := r.schemas[name]
	if !ok {
		return fmt.Errorf("unknown schema: %s", name)
	}

	// Create new instance with defaults
	r.instances[name] = factory()
	r.active[name] = true
	return nil
}

// Deactivate deactivates a schema
func (r *SchemaRegistry) Deactivate(name string) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	if _, ok := r.schemas[name]; !ok {
		return fmt.Errorf("unknown schema: %s", name)
	}

	delete(r.instances, name)
	r.active[name] = false
	return nil
}

// Get returns the active instance of a schema (nil if not active)
func (r *SchemaRegistry) Get(name string) interface{} {
	r.mu.RLock()
	defer r.mu.RUnlock()
	return r.instances[name]
}

// GetActive returns all active schema names
func (r *SchemaRegistry) GetActive() []string {
	r.mu.RLock()
	defer r.mu.RUnlock()
	var result []string
	for name, active := range r.active {
		if active {
			result = append(result, name)
		}
	}
	return result
}

// ResetAll resets all schemas to their default activation state
func (r *SchemaRegistry) ResetAll() {
	r.mu.Lock()
	defer r.mu.Unlock()

	r.instances = make(map[string]interface{})
	{{- range $t := .Types}}
	{{- if isRoot $t}}
	r.active["{{$t.Name}}"] = {{isActiveByDefault $t}}
	{{- if isActiveByDefault $t}}
	r.instances["{{$t.Name}}"] = r.schemas["{{$t.Name}}"]()
	{{- end}}
	{{- end}}
	{{- end}}
}

// Typed getters for convenience
{{range $t := .Types}}
{{- if isRoot $t}}
// Get{{$t.Name}} returns the active {{$t.Name}} instance (nil if not active)
func Get{{$t.Name}}Instance() *{{$t.Name}} {
	inst := GetSchemaRegistry().Get("{{$t.Name}}")
	if inst == nil {
		return nil
	}
	return inst.(*{{$t.Name}})
}

// Activate{{$t.Name}} activates the {{$t.Name}} schema with defaults
func Activate{{$t.Name}}() error {
	return GetSchemaRegistry().Activate("{{$t.Name}}")
}

// Deactivate{{$t.Name}} deactivates the {{$t.Name}} schema
func Deactivate{{$t.Name}}() error {
	return GetSchemaRegistry().Deactivate("{{$t.Name}}")
}

// Is{{$t.Name}}Active returns true if {{$t.Name}} is active
func Is{{$t.Name}}Active() bool {
	return GetSchemaRegistry().IsActive("{{$t.Name}}")
}
{{end}}
{{end}}
`
