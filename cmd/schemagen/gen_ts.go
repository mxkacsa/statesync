package main

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"
)

// GenerateTS generates TypeScript code from a schema file
func GenerateTS(schema *SchemaFile) ([]byte, error) {
	tmpl, err := template.New("ts").Funcs(template.FuncMap{
		"tsType":      TSType,
		"tsFieldType": TSFieldType,
		"parseType":   ParseType,
		"isPrimitive": IsPrimitive,
		"lower":       strings.ToLower,
	}).Parse(tsTemplate)
	if err != nil {
		return nil, fmt.Errorf("template parse error: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, schema); err != nil {
		return nil, fmt.Errorf("template execute error: %w", err)
	}

	return buf.Bytes(), nil
}

const tsTemplate = `// Code generated by schemagen. DO NOT EDIT.

import { Schema, SchemaRegistry, SyncState, defineSchema, FieldType, Decoder } from '@statediff/client';

{{range .Types}}
// {{.Name}} interface
export interface {{.Name}} {
{{- range .Fields}}
  {{.Name}}: {{tsType .Type}};
{{- end}}
}
{{end}}

// Schema definitions
{{range .Types}}
export const {{.Name}}Schema: Schema = defineSchema(
  {{.ID}},
  '{{.Name}}',
  [
{{- range $i, $f := .Fields}}
{{- $pt := parseType $f.Type}}
    {
      name: '{{$f.Name}}',
      type: {{tsFieldType $f.Type}},
{{- if $pt.IsArray}}
      elemType: {{tsFieldType $pt.ElemType}},
{{- if not (isPrimitive $pt.ElemType)}}
      childSchema: {{$pt.ElemType}}Schema,
{{- end}}
{{- if $f.Key}}
      keyField: '{{$f.Key}}',
{{- end}}
{{- else if $pt.IsMap}}
      elemType: {{tsFieldType $pt.ElemType}},
{{- if not (isPrimitive $pt.ElemType)}}
      childSchema: {{$pt.ElemType}}Schema,
{{- end}}
{{- else if not (isPrimitive $f.Type)}}
      childSchema: {{$f.Type}}Schema,
{{- end}}
    },
{{- end}}
  ]
);
{{end}}

// Create and configure registry
export function createRegistry(): SchemaRegistry {
  const registry = new SchemaRegistry();
{{range .Types}}
  registry.register({{.Name}}Schema);
{{- end}}
  return registry;
}

{{range .Types}}
// {{.Name}} state container
export function create{{.Name}}State(registry?: SchemaRegistry): SyncState<{{.Name}}> {
  const reg = registry || createRegistry();
  return new SyncState<{{.Name}}>({{.Name}}Schema, reg, {
{{- range .Fields}}
{{- $pt := parseType .Type}}
{{- if $pt.IsArray}}
    {{.Name}}: [],
{{- else if $pt.IsMap}}
    {{.Name}}: {},
{{- else if eq .Type "string"}}
    {{.Name}}: '',
{{- else if eq .Type "bool"}}
    {{.Name}}: false,
{{- else if or (isPrimitive .Type) (eq .Type "int") (eq .Type "uint")}}
    {{.Name}}: 0,
{{- else}}
    {{.Name}}: {} as {{.Type}},
{{- end}}
{{- end}}
  });
}
{{end}}

{{if .Views}}
// View types for projections
{{range .Views}}
export type {{.Name}}View = '{{.Name}}';
{{end}}

export type ViewType = {{range $i, $v := .Views}}{{if $i}} | {{end}}'{{$v.Name}}'{{end}};
{{end}}

// Re-export types for convenience
export { FieldType, Operation, Decoder, SchemaRegistry, SyncState } from '@statediff/client';
`
