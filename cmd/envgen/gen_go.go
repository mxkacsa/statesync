package main

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"
)

// GenerateGo generates Go code from the config schema
func GenerateGo(config *ConfigFile) ([]byte, error) {
	tmpl := template.Must(template.New("go").Funcs(template.FuncMap{
		"goType":          GoType,
		"goDefault":       goDefault,
		"goValidation":    goValidation,
		"upperFirst":      upperFirst,
		"lowerFirst":      lowerFirst,
		"toEnvName":       toEnvName,
		"hasValidation":   hasValidation,
		"needsTimeImport": needsTimeImport,
	}).Parse(goTemplate))

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, config); err != nil {
		return nil, fmt.Errorf("template error: %w", err)
	}

	return buf.Bytes(), nil
}

func goDefault(f *FieldDef) string {
	if f.Default == nil {
		return DefaultForType(f.Type)
	}

	switch v := f.Default.(type) {
	case string:
		return fmt.Sprintf("%q", v)
	case bool:
		return fmt.Sprintf("%t", v)
	case int64:
		return fmt.Sprintf("%d", v)
	case uint64:
		return fmt.Sprintf("%d", v)
	case float64:
		// Check if it's a whole number
		if v == float64(int64(v)) {
			return fmt.Sprintf("%d", int64(v))
		}
		return fmt.Sprintf("%v", v)
	default:
		return fmt.Sprintf("%v", v)
	}
}

func goValidation(f *FieldDef) string {
	var parts []string

	if f.Min != nil {
		parts = append(parts, fmt.Sprintf("if c.%s < %v { return fmt.Errorf(\"%s must be >= %v, got %%v\", c.%s) }",
			f.Name, *f.Min, f.Name, *f.Min, f.Name))
	}

	if f.Max != nil {
		parts = append(parts, fmt.Sprintf("if c.%s > %v { return fmt.Errorf(\"%s must be <= %v, got %%v\", c.%s) }",
			f.Name, *f.Max, f.Name, *f.Max, f.Name))
	}

	if len(f.Options) > 0 {
		optChecks := make([]string, len(f.Options))
		for i, opt := range f.Options {
			optChecks[i] = fmt.Sprintf("c.%s != %q", f.Name, opt)
		}
		parts = append(parts, fmt.Sprintf("if %s { return fmt.Errorf(\"%s must be one of [%s], got %%v\", c.%s) }",
			strings.Join(optChecks, " && "), f.Name, strings.Join(f.Options, ", "), f.Name))
	}

	return strings.Join(parts, "\n\t")
}

func hasValidation(f *FieldDef) bool {
	return f.Min != nil || f.Max != nil || len(f.Options) > 0
}

func needsTimeImport(config *ConfigFile) bool {
	for _, c := range config.Configs {
		for _, f := range c.Fields {
			if f.Type == "duration" {
				return true
			}
		}
	}
	return false
}

func upperFirst(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

func lowerFirst(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToLower(s[:1]) + s[1:]
}

func toEnvName(configName, fieldName string) string {
	// Convert CamelCase to SCREAMING_SNAKE_CASE
	result := toSnakeCase(configName) + "_" + toSnakeCase(fieldName)
	return strings.ToUpper(result)
}

func toSnakeCase(s string) string {
	var result []rune
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result = append(result, '_')
		}
		result = append(result, r)
	}
	return string(result)
}

const goTemplate = `// Code generated by envgen. DO NOT EDIT.
package {{.Package}}

import (
	"fmt"
	"os"
	"strconv"
	"sync"
{{- if needsTimeImport .}}
	"time"
{{- end}}

	"github.com/mxkacsa/tinyconf"
)

{{range .Configs}}
// {{.Name}} holds configuration values for {{.Name | lowerFirst}}
type {{.Name}} struct {
{{- range .Fields}}
	{{.Name}} {{goType .Type}} ` + "`json:\"{{.Name | lowerFirst}}\"{{if .Env}} env:\"{{.Env}}\"{{end}}`" + ` {{if .Description}}// {{.Description}}{{end}}
{{- end}}
}

// Default{{.Name}} returns a new {{.Name}} with default values
func Default{{.Name}}() *{{.Name}} {
	return &{{.Name}}{
{{- range .Fields}}
		{{.Name}}: {{goDefault .}},
{{- end}}
	}
}

// Validate validates the configuration values
func (c *{{.Name}}) Validate() error {
{{- range .Fields}}
{{- if hasValidation .}}
	{{goValidation .}}
{{- end}}
{{- end}}
	return nil
}

// LoadFromEnv loads values from environment variables (overrides existing values)
func (c *{{.Name}}) LoadFromEnv() {
{{- $configName := .Name}}
{{- range .Fields}}
	{{- $envName := toEnvName $configName .Name}}
	{{- if .Env}}
	{{- $envName = .Env}}
	{{- end}}
	if v := os.Getenv("{{$envName}}"); v != "" {
		{{- if eq .Type "string"}}
		c.{{.Name}} = v
		{{- else if eq .Type "bool"}}
		c.{{.Name}} = v == "true" || v == "1"
		{{- else if or (eq .Type "int") (eq .Type "int32") (eq .Type "int64")}}
		if parsed, err := strconv.ParseInt(v, 10, 64); err == nil {
			c.{{.Name}} = {{goType .Type}}(parsed)
		}
		{{- else if or (eq .Type "uint") (eq .Type "uint32") (eq .Type "uint64")}}
		if parsed, err := strconv.ParseUint(v, 10, 64); err == nil {
			c.{{.Name}} = {{goType .Type}}(parsed)
		}
		{{- else if or (eq .Type "float32") (eq .Type "float64")}}
		if parsed, err := strconv.ParseFloat(v, 64); err == nil {
			c.{{.Name}} = {{goType .Type}}(parsed)
		}
		{{- else if eq .Type "duration"}}
		if parsed, err := strconv.ParseInt(v, 10, 64); err == nil {
			c.{{.Name}} = time.Duration(parsed) * time.Second
		}
		{{- end}}
	}
{{- end}}
}

var (
	{{.Name | lowerFirst}}Instance *{{.Name}}
	{{.Name | lowerFirst}}Once     sync.Once
	{{.Name | lowerFirst}}Conf     *tinyconf.TinyConf
)

// Get{{.Name}} returns the singleton instance of {{.Name}}
// It loads from config file on first call, or creates with defaults if not exists
func Get{{.Name}}() *{{.Name}} {
	{{.Name | lowerFirst}}Once.Do(func() {
		{{.Name | lowerFirst}}Instance = Default{{.Name}}()
		{{.Name | lowerFirst}}Conf = tinyconf.NewTinyConf("{{.Name | lowerFirst}}.json")

		// Load from file (creates with defaults if not exists)
		_ = {{.Name | lowerFirst}}Conf.Load({{.Name | lowerFirst}}Instance)

		// Override with environment variables
		{{.Name | lowerFirst}}Instance.LoadFromEnv()
	})
	return {{.Name | lowerFirst}}Instance
}

// Reload{{.Name}} reloads the configuration from file
func Reload{{.Name}}() error {
	if {{.Name | lowerFirst}}Conf == nil {
		Get{{.Name}}() // Initialize if not done
	}

	if err := {{.Name | lowerFirst}}Conf.Load({{.Name | lowerFirst}}Instance); err != nil {
		return err
	}

	// Override with environment variables
	{{.Name | lowerFirst}}Instance.LoadFromEnv()

	return {{.Name | lowerFirst}}Instance.Validate()
}

// Save{{.Name}} saves the current configuration to file
func Save{{.Name}}() error {
	if {{.Name | lowerFirst}}Conf == nil {
		Get{{.Name}}() // Initialize if not done
	}

	if err := {{.Name | lowerFirst}}Instance.Validate(); err != nil {
		return err
	}

	return {{.Name | lowerFirst}}Conf.Save({{.Name | lowerFirst}}Instance)
}

// Set{{.Name}}Path sets the config file path (must be called before first Get{{.Name}})
func Set{{.Name}}Path(path string) {
	{{.Name | lowerFirst}}Conf = tinyconf.NewTinyConf(path)
}
{{end}}
`
