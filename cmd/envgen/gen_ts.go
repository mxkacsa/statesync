package main

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"
)

// GenerateTS generates TypeScript code from the config schema
func GenerateTS(config *ConfigFile) ([]byte, error) {
	tmpl := template.Must(template.New("ts").Funcs(template.FuncMap{
		"tsType":        TSType,
		"tsDefault":     tsDefault,
		"lowerFirst":    lowerFirst,
		"tsValidation":  tsValidation,
		"hasValidation": hasValidation,
		"join":          strings.Join,
	}).Parse(tsTemplate))

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, config); err != nil {
		return nil, fmt.Errorf("template error: %w", err)
	}

	return buf.Bytes(), nil
}

func tsDefault(f *FieldDef) string {
	if f.Default == nil {
		return tsZeroValue(f.Type)
	}

	switch v := f.Default.(type) {
	case string:
		return fmt.Sprintf("'%s'", v)
	case bool:
		return fmt.Sprintf("%t", v)
	case int64:
		return fmt.Sprintf("%d", v)
	case uint64:
		return fmt.Sprintf("%d", v)
	case float64:
		if v == float64(int64(v)) {
			return fmt.Sprintf("%d", int64(v))
		}
		return fmt.Sprintf("%v", v)
	default:
		return fmt.Sprintf("%v", v)
	}
}

func tsZeroValue(t string) string {
	pt := ParseType(t)

	if pt.IsArray {
		return "[]"
	}
	if pt.IsMap {
		return "{}"
	}

	switch pt.BaseType {
	case "string":
		return "''"
	case "bool":
		return "false"
	default:
		return "0"
	}
}

func tsValidation(f *FieldDef) string {
	var parts []string

	if f.Min != nil {
		parts = append(parts, fmt.Sprintf("if (config.%s < %v) { errors.push('%s must be >= %v'); }",
			lowerFirst(f.Name), *f.Min, f.Name, *f.Min))
	}

	if f.Max != nil {
		parts = append(parts, fmt.Sprintf("if (config.%s > %v) { errors.push('%s must be <= %v'); }",
			lowerFirst(f.Name), *f.Max, f.Name, *f.Max))
	}

	if len(f.Options) > 0 {
		optList := make([]string, len(f.Options))
		for i, opt := range f.Options {
			optList[i] = fmt.Sprintf("'%s'", opt)
		}
		parts = append(parts, fmt.Sprintf("if (![%s].includes(config.%s)) { errors.push('%s must be one of [%s]'); }",
			strings.Join(optList, ", "), lowerFirst(f.Name), f.Name, strings.Join(f.Options, ", ")))
	}

	return strings.Join(parts, "\n  ")
}

const tsTemplate = `// Code generated by envgen. DO NOT EDIT.

{{range .Configs}}
/**
 * {{.Name}} configuration interface
 */
export interface {{.Name}} {
{{- range .Fields}}
  /** {{if .Description}}{{.Description}}{{else}}{{.Name}} configuration value{{end}} */
  {{.Name | lowerFirst}}: {{tsType .Type}};
{{- end}}
}

/**
 * Default {{.Name}} configuration values
 */
export const default{{.Name}}: {{.Name}} = {
{{- range .Fields}}
  {{.Name | lowerFirst}}: {{tsDefault .}},
{{- end}}
};

/**
 * Validate {{.Name}} configuration
 * @returns Array of error messages (empty if valid)
 */
export function validate{{.Name}}(config: {{.Name}}): string[] {
  const errors: string[] = [];
{{- range .Fields}}
{{- if hasValidation .}}
  {{tsValidation .}}
{{- end}}
{{- end}}
  return errors;
}

/**
 * {{.Name}} configuration metadata for UI generation
 */
export const {{.Name | lowerFirst}}Schema = {
{{- range .Fields}}
  {{.Name | lowerFirst}}: {
    type: '{{.Type}}' as const,
    {{- if .Default}}
    default: {{tsDefault .}},
    {{- end}}
    {{- if .Min}}
    min: {{.Min}},
    {{- end}}
    {{- if .Max}}
    max: {{.Max}},
    {{- end}}
    {{- if .Options}}
    options: [{{range $i, $opt := .Options}}{{if $i}}, {{end}}'{{$opt}}'{{end}}] as const,
    {{- end}}
    {{- if .Description}}
    description: '{{.Description}}',
    {{- end}}
    {{- if .Required}}
    required: true,
    {{- end}}
  },
{{- end}}
} as const;

/**
 * Create a {{.Name}} instance with partial values
 */
export function create{{.Name}}(partial: Partial<{{.Name}}>): {{.Name}} {
  return { ...default{{.Name}}, ...partial };
}

{{end}}
/**
 * Helper to deep merge configs
 */
export function mergeConfig<T extends object>(base: T, override: Partial<T>): T {
  const result = { ...base };
  for (const key in override) {
    if (override[key] !== undefined) {
      result[key] = override[key] as T[Extract<keyof T, string>];
    }
  }
  return result;
}
`
