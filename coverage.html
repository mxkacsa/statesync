
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>clonegen: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/mxkacsa/statediff/cmd/clonegen/generator.go (64.1%)</option>
				
				<option value="file1">github.com/mxkacsa/statediff/cmd/clonegen/main.go (50.0%)</option>
				
				<option value="file2">github.com/mxkacsa/statediff/cmd/clonegen/parser.go (42.7%)</option>
				
				<option value="file3">github.com/mxkacsa/statediff/cmd/clonegen/types.go (54.0%)</option>
				
				<option value="file4">github.com/mxkacsa/statediff/diff.go (93.8%)</option>
				
				<option value="file5">github.com/mxkacsa/statediff/effect.go (100.0%)</option>
				
				<option value="file6">github.com/mxkacsa/statediff/example/main.go (0.0%)</option>
				
				<option value="file7">github.com/mxkacsa/statediff/persist.go (87.1%)</option>
				
				<option value="file8">github.com/mxkacsa/statediff/session.go (96.9%)</option>
				
				<option value="file9">github.com/mxkacsa/statediff/state.go (97.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "bytes"
        "fmt"
        "go/format"
        "strings"
        "text/template"
)

// Generator generates Clone() method code
type Generator struct {
        packageName     string
        pointerReceiver bool
        skipFields      map[string]bool
        imports         map[string]bool
        warnings        []string
}

// NewGenerator creates a new code generator
func NewGenerator(packageName string, pointerReceiver bool, skipFields []string) *Generator <span class="cov8" title="1">{
        skip := make(map[string]bool)
        for _, f := range skipFields </span><span class="cov0" title="0">{
                skip[f] = true
        }</span>
        <span class="cov8" title="1">return &amp;Generator{
                packageName:     packageName,
                pointerReceiver: pointerReceiver,
                skipFields:      skip,
                imports:         make(map[string]bool),
        }</span>
}

// Generate generates code for all types
func (g *Generator) Generate(types []*TypeInfo) ([]byte, error) <span class="cov8" title="1">{
        var methods []string

        for _, t := range types </span><span class="cov8" title="1">{
                method, err := g.generateCloneMethod(t)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("generate %s: %w", t.Name, err)
                }</span>
                <span class="cov8" title="1">methods = append(methods, method)</span>
        }

        // Build imports
        <span class="cov8" title="1">var importLines []string
        for imp := range g.imports </span><span class="cov0" title="0">{
                importLines = append(importLines, fmt.Sprintf("\t%q", imp))
        }</span>

        // Generate final file
        <span class="cov8" title="1">var buf bytes.Buffer
        buf.WriteString("// Code generated by clonegen. DO NOT EDIT.\n")
        buf.WriteString("//go:build !clonegen_ignore\n\n")
        buf.WriteString(fmt.Sprintf("package %s\n\n", g.packageName))

        if len(importLines) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString("import (\n")
                for _, imp := range importLines </span><span class="cov0" title="0">{
                        buf.WriteString(imp + "\n")
                }</span>
                <span class="cov0" title="0">buf.WriteString(")\n\n")</span>
        }

        // Add warnings as comments
        <span class="cov8" title="1">if len(g.warnings) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString("// Generation warnings:\n")
                for _, w := range g.warnings </span><span class="cov0" title="0">{
                        buf.WriteString(fmt.Sprintf("//   - %s\n", w))
                }</span>
                <span class="cov0" title="0">buf.WriteString("\n")</span>
        }

        <span class="cov8" title="1">for _, method := range methods </span><span class="cov8" title="1">{
                buf.WriteString(method)
                buf.WriteString("\n")
        }</span>

        // Format the code
        <span class="cov8" title="1">formatted, err := format.Source(buf.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                // Return unformatted if formatting fails (helps debugging)
                return buf.Bytes(), nil
        }</span>

        <span class="cov8" title="1">return formatted, nil</span>
}

// generateCloneMethod generates Clone() for a single type
func (g *Generator) generateCloneMethod(t *TypeInfo) (string, error) <span class="cov8" title="1">{
        var buf bytes.Buffer

        receiver := "src"
        receiverType := t.Name
        if g.pointerReceiver </span><span class="cov0" title="0">{
                receiverType = "*" + t.Name
        }</span>

        <span class="cov8" title="1">buf.WriteString(fmt.Sprintf("// Clone creates a deep copy of %s\n", t.Name))
        buf.WriteString(fmt.Sprintf("func (%s %s) Clone() %s {\n", receiver, receiverType, t.Name))

        // Collect primitive assignments and complex fields
        var primitiveAssigns []string
        var complexFields []*FieldInfo

        for _, field := range t.Fields </span><span class="cov8" title="1">{
                if g.skipFields[field.Name] </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if !field.IsExported &amp;&amp; !field.Embedded </span><span class="cov0" title="0">{
                        g.warnings = append(g.warnings, fmt.Sprintf("%s.%s: unexported field - skipped", t.Name, field.Name))
                        continue</span>
                }

                <span class="cov8" title="1">if field.Warning != "" </span><span class="cov0" title="0">{
                        g.warnings = append(g.warnings, fmt.Sprintf("%s.%s: %s", t.Name, field.Name, field.Warning))
                }</span>

                <span class="cov8" title="1">switch field.Kind </span>{
                case KindPrimitive, KindString, KindTime, KindInterface, KindChan, KindFunc:<span class="cov8" title="1">
                        primitiveAssigns = append(primitiveAssigns, field.Name)</span>
                default:<span class="cov8" title="1">
                        complexFields = append(complexFields, field)</span>
                }
        }

        // Generate dst initialization with primitive fields
        <span class="cov8" title="1">buf.WriteString(fmt.Sprintf("\tdst := %s{\n", t.Name))
        for _, name := range primitiveAssigns </span><span class="cov8" title="1">{
                buf.WriteString(fmt.Sprintf("\t\t%s: %s.%s,\n", name, receiver, name))
        }</span>
        <span class="cov8" title="1">buf.WriteString("\t}\n")

        // Generate complex field cloning
        for _, field := range complexFields </span><span class="cov8" title="1">{
                code := g.generateFieldClone(field, receiver)
                buf.WriteString("\n")
                buf.WriteString(code)
        }</span>

        <span class="cov8" title="1">buf.WriteString("\n\treturn dst\n")
        buf.WriteString("}\n")

        return buf.String(), nil</span>
}

// generateFieldClone generates cloning code for a complex field
func (g *Generator) generateFieldClone(field *FieldInfo, receiver string) string <span class="cov8" title="1">{
        var buf bytes.Buffer
        src := fmt.Sprintf("%s.%s", receiver, field.Name)
        dst := fmt.Sprintf("dst.%s", field.Name)

        switch field.Kind </span>{
        case KindSlice:<span class="cov8" title="1">
                buf.WriteString(g.generateSliceClone(field, src, dst))</span>

        case KindArray:<span class="cov8" title="1">
                buf.WriteString(g.generateArrayClone(field, src, dst))</span>

        case KindMap:<span class="cov8" title="1">
                buf.WriteString(g.generateMapClone(field, src, dst))</span>

        case KindPointer:<span class="cov8" title="1">
                buf.WriteString(g.generatePointerClone(field, src, dst))</span>

        case KindStruct:<span class="cov0" title="0">
                if field.Embedded </span><span class="cov0" title="0">{
                        if field.HasClone </span><span class="cov0" title="0">{
                                buf.WriteString(fmt.Sprintf("\t%s = %s.Clone()\n", dst, src))
                        }</span> else<span class="cov0" title="0"> {
                                buf.WriteString(fmt.Sprintf("\t%s = %s // embedded struct - shallow copy\n", dst, src))
                        }</span>
                } else<span class="cov0" title="0"> {
                        if field.HasClone </span><span class="cov0" title="0">{
                                buf.WriteString(fmt.Sprintf("\t%s = %s.Clone()\n", dst, src))
                        }</span> else<span class="cov0" title="0"> {
                                buf.WriteString(fmt.Sprintf("\t%s = %s // struct without Clone - shallow copy\n", dst, src))
                        }</span>
                }

        default:<span class="cov0" title="0">
                // Shallow copy for unknown/interface/chan/func
                buf.WriteString(fmt.Sprintf("\t%s = %s // %s\n", dst, src, field.Kind))</span>
        }

        <span class="cov8" title="1">return buf.String()</span>
}

// generateSliceClone generates slice cloning code
func (g *Generator) generateSliceClone(field *FieldInfo, src, dst string) string <span class="cov8" title="1">{
        var buf bytes.Buffer

        buf.WriteString(fmt.Sprintf("\tif %s != nil {\n", src))
        buf.WriteString(fmt.Sprintf("\t\t%s = make(%s, len(%s))\n", dst, field.TypeStr, src))

        elemClone := g.getElemCloneExpr(field, "v")

        if elemClone == "v" </span><span class="cov8" title="1">{
                // Simple copy for primitives
                buf.WriteString(fmt.Sprintf("\t\tcopy(%s, %s)\n", dst, src))
        }</span> else<span class="cov8" title="1"> {
                buf.WriteString(fmt.Sprintf("\t\tfor i, v := range %s {\n", src))
                buf.WriteString(fmt.Sprintf("\t\t\t%s[i] = %s\n", dst, elemClone))
                buf.WriteString("\t\t}\n")
        }</span>

        <span class="cov8" title="1">buf.WriteString("\t}\n")
        return buf.String()</span>
}

// generateArrayClone generates array cloning code
func (g *Generator) generateArrayClone(field *FieldInfo, src, dst string) string <span class="cov8" title="1">{
        var buf bytes.Buffer

        elemClone := g.getElemCloneExpr(field, "v")

        if elemClone == "v" </span><span class="cov8" title="1">{
                // Simple assignment for arrays of primitives
                buf.WriteString(fmt.Sprintf("\t%s = %s\n", dst, src))
        }</span> else<span class="cov0" title="0"> {
                buf.WriteString(fmt.Sprintf("\tfor i, v := range %s {\n", src))
                buf.WriteString(fmt.Sprintf("\t\t%s[i] = %s\n", dst, elemClone))
                buf.WriteString("\t}\n")
        }</span>

        <span class="cov8" title="1">return buf.String()</span>
}

// generateMapClone generates map cloning code
func (g *Generator) generateMapClone(field *FieldInfo, src, dst string) string <span class="cov8" title="1">{
        var buf bytes.Buffer

        buf.WriteString(fmt.Sprintf("\tif %s != nil {\n", src))
        buf.WriteString(fmt.Sprintf("\t\t%s = make(%s, len(%s))\n", dst, field.TypeStr, src))

        elemClone := g.getMapValueCloneExpr(field, "v")

        buf.WriteString(fmt.Sprintf("\t\tfor k, v := range %s {\n", src))
        buf.WriteString(fmt.Sprintf("\t\t\t%s[k] = %s\n", dst, elemClone))
        buf.WriteString("\t\t}\n")
        buf.WriteString("\t}\n")

        return buf.String()
}</span>

// generatePointerClone generates pointer cloning code
func (g *Generator) generatePointerClone(field *FieldInfo, src, dst string) string <span class="cov8" title="1">{
        var buf bytes.Buffer

        buf.WriteString(fmt.Sprintf("\tif %s != nil {\n", src))

        switch field.ElemKind </span>{
        case KindPrimitive, KindString:<span class="cov0" title="0">
                buf.WriteString(fmt.Sprintf("\t\tv := *%s\n", src))
                buf.WriteString(fmt.Sprintf("\t\t%s = &amp;v\n", dst))</span>

        case KindStruct:<span class="cov8" title="1">
                if field.HasClone </span><span class="cov0" title="0">{
                        buf.WriteString(fmt.Sprintf("\t\tv := %s.Clone()\n", src))
                        buf.WriteString(fmt.Sprintf("\t\t%s = &amp;v\n", dst))
                }</span> else<span class="cov8" title="1"> {
                        buf.WriteString(fmt.Sprintf("\t\tv := *%s // struct without Clone - shallow copy\n", src))
                        buf.WriteString(fmt.Sprintf("\t\t%s = &amp;v\n", dst))
                }</span>

        case KindSlice:<span class="cov0" title="0">
                // Pointer to slice
                buf.WriteString(fmt.Sprintf("\t\tsliceCopy := make(%s, len(*%s))\n", field.ElemType, src))
                buf.WriteString(fmt.Sprintf("\t\tcopy(sliceCopy, *%s)\n", src))
                buf.WriteString(fmt.Sprintf("\t\t%s = &amp;sliceCopy\n", dst))</span>

        case KindMap:<span class="cov0" title="0">
                // Pointer to map - need to clone the map
                buf.WriteString(fmt.Sprintf("\t\tmapCopy := make(%s, len(*%s))\n", field.ElemType, src))
                buf.WriteString(fmt.Sprintf("\t\tfor k, v := range *%s {\n", src))
                buf.WriteString("\t\t\tmapCopy[k] = v\n")
                buf.WriteString("\t\t}\n")
                buf.WriteString(fmt.Sprintf("\t\t%s = &amp;mapCopy\n", dst))</span>

        default:<span class="cov0" title="0">
                buf.WriteString(fmt.Sprintf("\t\tv := *%s\n", src))
                buf.WriteString(fmt.Sprintf("\t\t%s = &amp;v\n", dst))</span>
        }

        <span class="cov8" title="1">buf.WriteString("\t}\n")
        return buf.String()</span>
}

// getElemCloneExpr returns the expression to clone a slice/array element
func (g *Generator) getElemCloneExpr(field *FieldInfo, varName string) string <span class="cov8" title="1">{
        switch field.ElemKind </span>{
        case KindPrimitive, KindString, KindTime, KindInterface:<span class="cov8" title="1">
                return varName</span>

        case KindStruct:<span class="cov8" title="1">
                if field.HasClone </span><span class="cov0" title="0">{
                        return varName + ".Clone()"
                }</span>
                <span class="cov8" title="1">return varName</span>

        case KindPointer:<span class="cov0" title="0">
                // Pointer element in slice, e.g., []*Item
                if field.HasClone </span><span class="cov0" title="0">{
                        return fmt.Sprintf("func() %s { if %s == nil { return nil }; v := %s.Clone(); return &amp;v }()",
                                field.ElemType, varName, varName)
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("func() %s { if %s == nil { return nil }; v := *%s; return &amp;v }()",
                        field.ElemType, varName, varName)</span>

        case KindSlice:<span class="cov8" title="1">
                // Nested slice
                return fmt.Sprintf("append(%s(nil), %s...)", field.ElemType, varName)</span>

        case KindMap:<span class="cov0" title="0">
                // Map in slice - simplified shallow copy
                return varName</span>

        default:<span class="cov0" title="0">
                return varName</span>
        }
}

// getMapValueCloneExpr returns the expression to clone a map value
func (g *Generator) getMapValueCloneExpr(field *FieldInfo, varName string) string <span class="cov8" title="1">{
        switch field.ElemKind </span>{
        case KindPrimitive, KindString, KindTime, KindInterface:<span class="cov8" title="1">
                return varName</span>

        case KindStruct:<span class="cov0" title="0">
                if field.HasClone </span><span class="cov0" title="0">{
                        return varName + ".Clone()"
                }</span>
                <span class="cov0" title="0">return varName</span>

        case KindPointer:<span class="cov0" title="0">
                if field.HasClone </span><span class="cov0" title="0">{
                        return fmt.Sprintf("func() %s { if %s == nil { return nil }; v := %s.Clone(); return &amp;v }()",
                                field.ElemType, varName, varName)
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("func() %s { if %s == nil { return nil }; v := *%s; return &amp;v }()",
                        field.ElemType, varName, varName)</span>

        case KindSlice:<span class="cov0" title="0">
                return fmt.Sprintf("append(%s(nil), %s...)", field.ElemType, varName)</span>

        default:<span class="cov8" title="1">
                return varName</span>
        }
}

// Unused but kept for potential template-based generation
var _ = template.FuncMap{
        "lower": strings.ToLower,
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// clonegen generates Clone() methods for Go structs.
//
// Usage:
//
//        //go:generate clonegen -type=GameState,Player
//
//        go generate ./...
package main

import (
        "flag"
        "fmt"
        "os"
        "strings"
)

var (
        typeNames       = flag.String("type", "", "comma-separated list of type names (required)")
        output          = flag.String("output", "", "output file name (default: {package}_clone_gen.go)")
        pointerReceiver = flag.Bool("pointer-receiver", false, "use pointer receiver: func (src *T) Clone() T")
        skipFields      = flag.String("skip-fields", "", "comma-separated fields to skip (shallow copy)")
        cloneMethod     = flag.String("clone-method", "Clone", "name of clone method to look for on nested types")
        verbose         = flag.Bool("verbose", false, "print detailed generation info")
)

func main() <span class="cov0" title="0">{
        flag.Parse()

        if *typeNames == "" </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "error: -type flag is required")
                flag.Usage()
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">types := strings.Split(*typeNames, ",")
        for i := range types </span><span class="cov0" title="0">{
                types[i] = strings.TrimSpace(types[i])
        }</span>

        <span class="cov0" title="0">skipFieldsList := []string{}
        if *skipFields != "" </span><span class="cov0" title="0">{
                skipFieldsList = strings.Split(*skipFields, ",")
                for i := range skipFieldsList </span><span class="cov0" title="0">{
                        skipFieldsList[i] = strings.TrimSpace(skipFieldsList[i])
                }</span>
        }

        <span class="cov0" title="0">cfg := Config{
                Types:           types,
                Output:          *output,
                PointerReceiver: *pointerReceiver,
                SkipFields:      skipFieldsList,
                CloneMethod:     *cloneMethod,
                Verbose:         *verbose,
        }

        if err := run(cfg); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: %v\n", err)
                os.Exit(1)
        }</span>
}

// Config holds generation configuration
type Config struct {
        Types           []string
        Output          string
        PointerReceiver bool
        SkipFields      []string
        CloneMethod     string
        Verbose         bool
}

func run(cfg Config) error <span class="cov8" title="1">{
        // Get the directory to process (current directory or from GOFILE env)
        dir := "."
        if gofile := os.Getenv("GOFILE"); gofile != "" </span><span class="cov0" title="0">{
                if cfg.Verbose </span><span class="cov0" title="0">{
                        fmt.Printf("Processing file: %s\n", gofile)
                }</span>
        }

        // Parse the package
        <span class="cov8" title="1">pkg, err := parsePackage(dir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("parse package: %w", err)
        }</span>

        <span class="cov8" title="1">if cfg.Verbose </span><span class="cov8" title="1">{
                fmt.Printf("Package: %s\n", pkg.Name)
                fmt.Printf("Types to generate: %v\n", cfg.Types)
        }</span>

        // Analyze types
        <span class="cov8" title="1">analyzer := NewAnalyzer(pkg, cfg.CloneMethod)
        typeInfos := make([]*TypeInfo, 0, len(cfg.Types))

        for _, typeName := range cfg.Types </span><span class="cov8" title="1">{
                info, err := analyzer.Analyze(typeName)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("analyze type %s: %w", typeName, err)
                }</span>
                <span class="cov8" title="1">typeInfos = append(typeInfos, info)

                if cfg.Verbose </span><span class="cov8" title="1">{
                        fmt.Printf("Analyzed %s: %d fields\n", typeName, len(info.Fields))
                }</span>
        }

        // Generate code
        <span class="cov8" title="1">gen := NewGenerator(pkg.Name, cfg.PointerReceiver, cfg.SkipFields)
        code, err := gen.Generate(typeInfos)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("generate: %w", err)
        }</span>

        // Determine output filename
        <span class="cov8" title="1">outputFile := cfg.Output
        if outputFile == "" </span><span class="cov0" title="0">{
                outputFile = fmt.Sprintf("%s_clone_gen.go", strings.ToLower(pkg.Name))
        }</span>

        // Write output
        <span class="cov8" title="1">if err := os.WriteFile(outputFile, code, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write file: %w", err)
        }</span>

        <span class="cov8" title="1">if cfg.Verbose </span><span class="cov8" title="1">{
                fmt.Printf("Generated: %s\n", outputFile)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "fmt"
        "go/ast"
        "go/parser"
        "go/token"
        "go/types"
        "os"
        "path/filepath"

        "golang.org/x/tools/go/packages"
)

// Package holds parsed package information
type Package struct {
        Name       string
        Dir        string
        Fset       *token.FileSet
        Files      []*ast.File
        TypesInfo  *types.Info
        TypesPkg   *types.Package
        Structs    map[string]*ast.StructType
        StructObjs map[string]*types.Struct
}

// parsePackage parses the Go package in the given directory
func parsePackage(dir string) (*Package, error) <span class="cov8" title="1">{
        absDir, err := filepath.Abs(dir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">cfg := &amp;packages.Config{
                Mode: packages.NeedName |
                        packages.NeedFiles |
                        packages.NeedTypes |
                        packages.NeedTypesInfo |
                        packages.NeedSyntax,
                Dir: absDir,
        }

        pkgs, err := packages.Load(cfg, ".")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("load package: %w", err)
        }</span>

        <span class="cov8" title="1">if len(pkgs) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no packages found in %s", dir)
        }</span>

        <span class="cov8" title="1">if len(pkgs[0].Errors) &gt; 0 </span><span class="cov0" title="0">{
                // Try fallback to AST-only parsing if type checking fails
                return parsePackageAST(absDir)
        }</span>

        <span class="cov8" title="1">p := pkgs[0]

        pkg := &amp;Package{
                Name:       p.Name,
                Dir:        absDir,
                Fset:       p.Fset,
                Files:      p.Syntax,
                TypesInfo:  p.TypesInfo,
                TypesPkg:   p.Types,
                Structs:    make(map[string]*ast.StructType),
                StructObjs: make(map[string]*types.Struct),
        }

        // Extract struct definitions
        for _, file := range p.Syntax </span><span class="cov8" title="1">{
                for _, decl := range file.Decls </span><span class="cov8" title="1">{
                        genDecl, ok := decl.(*ast.GenDecl)
                        if !ok || genDecl.Tok != token.TYPE </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">for _, spec := range genDecl.Specs </span><span class="cov8" title="1">{
                                typeSpec, ok := spec.(*ast.TypeSpec)
                                if !ok </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">structType, ok := typeSpec.Type.(*ast.StructType)
                                if !ok </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">name := typeSpec.Name.Name
                                pkg.Structs[name] = structType

                                // Get types.Struct from type info
                                if obj := p.Types.Scope().Lookup(name); obj != nil </span><span class="cov8" title="1">{
                                        if named, ok := obj.Type().(*types.Named); ok </span><span class="cov8" title="1">{
                                                if st, ok := named.Underlying().(*types.Struct); ok </span><span class="cov8" title="1">{
                                                        pkg.StructObjs[name] = st
                                                }</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">return pkg, nil</span>
}

// parsePackageAST parses package using only AST (fallback when type checking fails)
func parsePackageAST(dir string) (*Package, error) <span class="cov0" title="0">{
        fset := token.NewFileSet()

        entries, err := os.ReadDir(dir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var files []*ast.File
        var pkgName string

        for _, entry := range entries </span><span class="cov0" title="0">{
                if entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">name := entry.Name()
                if filepath.Ext(name) != ".go" </span><span class="cov0" title="0">{
                        continue</span>
                }
                // Skip test files and generated files
                <span class="cov0" title="0">if len(name) &gt; 8 &amp;&amp; name[len(name)-8:] == "_test.go" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if len(name) &gt; 12 &amp;&amp; name[len(name)-12:] == "_clone_gen.go" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">path := filepath.Join(dir, name)
                file, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if pkgName == "" </span><span class="cov0" title="0">{
                        pkgName = file.Name.Name
                }</span>
                <span class="cov0" title="0">files = append(files, file)</span>
        }

        <span class="cov0" title="0">if len(files) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no Go files found in %s", dir)
        }</span>

        <span class="cov0" title="0">pkg := &amp;Package{
                Name:       pkgName,
                Dir:        dir,
                Fset:       fset,
                Files:      files,
                Structs:    make(map[string]*ast.StructType),
                StructObjs: make(map[string]*types.Struct),
        }

        // Extract struct definitions from AST only
        for _, file := range files </span><span class="cov0" title="0">{
                for _, decl := range file.Decls </span><span class="cov0" title="0">{
                        genDecl, ok := decl.(*ast.GenDecl)
                        if !ok || genDecl.Tok != token.TYPE </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">for _, spec := range genDecl.Specs </span><span class="cov0" title="0">{
                                typeSpec, ok := spec.(*ast.TypeSpec)
                                if !ok </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov0" title="0">structType, ok := typeSpec.Type.(*ast.StructType)
                                if !ok </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov0" title="0">pkg.Structs[typeSpec.Name.Name] = structType</span>
                        }
                }
        }

        <span class="cov0" title="0">return pkg, nil</span>
}

// HasCloneMethod checks if a type has a Clone() method
func (p *Package) HasCloneMethod(typeName string, methodName string) bool <span class="cov8" title="1">{
        if p.TypesPkg == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">obj := p.TypesPkg.Scope().Lookup(typeName)
        if obj == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">named, ok := obj.Type().(*types.Named)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; named.NumMethods(); i++ </span><span class="cov8" title="1">{
                if named.Method(i).Name() == methodName </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        // Check pointer receiver methods too
        <span class="cov8" title="1">ptr := types.NewPointer(named)
        mset := types.NewMethodSet(ptr)
        for i := 0; i &lt; mset.Len(); i++ </span><span class="cov0" title="0">{
                if mset.At(i).Obj().Name() == methodName </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "fmt"
        "go/ast"
        "strings"
)

// TypeInfo holds analyzed type information
type TypeInfo struct {
        Name   string
        Fields []*FieldInfo
}

// FieldInfo holds analyzed field information
type FieldInfo struct {
        Name       string
        TypeExpr   ast.Expr      // Original AST expression
        TypeStr    string        // String representation
        Kind       FieldKind     // Categorized kind
        ElemKind   FieldKind     // Element kind for slices/maps/pointers
        KeyKind    FieldKind     // Key kind for maps
        ElemType   string        // Element type string
        KeyType    string        // Key type for maps
        HasClone   bool          // Whether the type has Clone() method
        IsExported bool          // Whether the field is exported
        Embedded   bool          // Whether this is an embedded field
        ArrayLen   string        // Array length for fixed arrays
        Warning    string        // Any warnings for this field
}

// FieldKind categorizes field types
type FieldKind int

const (
        KindPrimitive FieldKind = iota
        KindString
        KindSlice
        KindArray
        KindMap
        KindPointer
        KindStruct
        KindInterface
        KindChan
        KindFunc
        KindTime
        KindUnknown
)

func (k FieldKind) String() string <span class="cov0" title="0">{
        switch k </span>{
        case KindPrimitive:<span class="cov0" title="0">
                return "primitive"</span>
        case KindString:<span class="cov0" title="0">
                return "string"</span>
        case KindSlice:<span class="cov0" title="0">
                return "slice"</span>
        case KindArray:<span class="cov0" title="0">
                return "array"</span>
        case KindMap:<span class="cov0" title="0">
                return "map"</span>
        case KindPointer:<span class="cov0" title="0">
                return "pointer"</span>
        case KindStruct:<span class="cov0" title="0">
                return "struct"</span>
        case KindInterface:<span class="cov0" title="0">
                return "interface"</span>
        case KindChan:<span class="cov0" title="0">
                return "chan"</span>
        case KindFunc:<span class="cov0" title="0">
                return "func"</span>
        case KindTime:<span class="cov0" title="0">
                return "time"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// Analyzer analyzes struct types
type Analyzer struct {
        pkg         *Package
        cloneMethod string
}

// NewAnalyzer creates a new type analyzer
func NewAnalyzer(pkg *Package, cloneMethod string) *Analyzer <span class="cov8" title="1">{
        return &amp;Analyzer{
                pkg:         pkg,
                cloneMethod: cloneMethod,
        }
}</span>

// Analyze analyzes a named type
func (a *Analyzer) Analyze(typeName string) (*TypeInfo, error) <span class="cov8" title="1">{
        structType, ok := a.pkg.Structs[typeName]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("type %s not found", typeName)
        }</span>

        <span class="cov8" title="1">info := &amp;TypeInfo{
                Name:   typeName,
                Fields: make([]*FieldInfo, 0),
        }

        for _, field := range structType.Fields.List </span><span class="cov8" title="1">{
                fieldInfo := a.analyzeField(field)

                if len(field.Names) == 0 </span><span class="cov0" title="0">{
                        // Embedded field
                        fieldInfo.Embedded = true
                        fieldInfo.Name = fieldInfo.TypeStr
                        // Extract just the type name for embedded fields
                        if idx := strings.LastIndex(fieldInfo.TypeStr, "."); idx &gt;= 0 </span><span class="cov0" title="0">{
                                fieldInfo.Name = fieldInfo.TypeStr[idx+1:]
                        }</span>
                        // Remove pointer prefix for name
                        <span class="cov0" title="0">fieldInfo.Name = strings.TrimPrefix(fieldInfo.Name, "*")
                        info.Fields = append(info.Fields, fieldInfo)</span>
                } else<span class="cov8" title="1"> {
                        // Named field(s)
                        for _, name := range field.Names </span><span class="cov8" title="1">{
                                f := *fieldInfo // Copy
                                f.Name = name.Name
                                f.IsExported = ast.IsExported(name.Name)
                                info.Fields = append(info.Fields, &amp;f)
                        }</span>
                }
        }

        <span class="cov8" title="1">return info, nil</span>
}

// analyzeField analyzes a single field
func (a *Analyzer) analyzeField(field *ast.Field) *FieldInfo <span class="cov8" title="1">{
        info := &amp;FieldInfo{
                TypeExpr:   field.Type,
                TypeStr:    exprToString(field.Type),
                IsExported: true,
        }

        a.categorizeType(info, field.Type)

        return info
}</span>

// categorizeType determines the kind of a type expression
func (a *Analyzer) categorizeType(info *FieldInfo, expr ast.Expr) <span class="cov8" title="1">{
        switch t := expr.(type) </span>{
        case *ast.Ident:<span class="cov8" title="1">
                info.Kind = a.identKind(t.Name)
                if info.Kind == KindStruct </span><span class="cov0" title="0">{
                        info.HasClone = a.pkg.HasCloneMethod(t.Name, a.cloneMethod)
                }</span>

        case *ast.SelectorExpr:<span class="cov8" title="1">
                // Qualified identifier like time.Time or pkg.Type
                typeStr := exprToString(t)
                if typeStr == "time.Time" || typeStr == "time.Duration" </span><span class="cov8" title="1">{
                        info.Kind = KindTime
                }</span> else<span class="cov0" title="0"> {
                        info.Kind = KindStruct
                        // Can't easily check for Clone method on external types
                }</span>

        case *ast.StarExpr:<span class="cov8" title="1">
                info.Kind = KindPointer
                info.ElemType = exprToString(t.X)
                info.ElemKind = a.exprKind(t.X)
                if info.ElemKind == KindStruct </span><span class="cov8" title="1">{
                        if ident, ok := t.X.(*ast.Ident); ok </span><span class="cov8" title="1">{
                                info.HasClone = a.pkg.HasCloneMethod(ident.Name, a.cloneMethod)
                        }</span>
                }

        case *ast.ArrayType:<span class="cov8" title="1">
                if t.Len == nil </span><span class="cov8" title="1">{
                        // Slice
                        info.Kind = KindSlice
                }</span> else<span class="cov8" title="1"> {
                        // Fixed array
                        info.Kind = KindArray
                        info.ArrayLen = exprToString(t.Len)
                }</span>
                <span class="cov8" title="1">info.ElemType = exprToString(t.Elt)
                info.ElemKind = a.exprKind(t.Elt)
                if info.ElemKind == KindStruct </span><span class="cov8" title="1">{
                        if ident, ok := t.Elt.(*ast.Ident); ok </span><span class="cov8" title="1">{
                                info.HasClone = a.pkg.HasCloneMethod(ident.Name, a.cloneMethod)
                        }</span>
                }
                // Check for pointer to struct
                <span class="cov8" title="1">if star, ok := t.Elt.(*ast.StarExpr); ok </span><span class="cov0" title="0">{
                        if ident, ok := star.X.(*ast.Ident); ok </span><span class="cov0" title="0">{
                                info.HasClone = a.pkg.HasCloneMethod(ident.Name, a.cloneMethod)
                        }</span>
                }

        case *ast.MapType:<span class="cov8" title="1">
                info.Kind = KindMap
                info.KeyType = exprToString(t.Key)
                info.KeyKind = a.exprKind(t.Key)
                info.ElemType = exprToString(t.Value)
                info.ElemKind = a.exprKind(t.Value)
                if info.ElemKind == KindStruct </span><span class="cov8" title="1">{
                        if ident, ok := t.Value.(*ast.Ident); ok </span><span class="cov8" title="1">{
                                info.HasClone = a.pkg.HasCloneMethod(ident.Name, a.cloneMethod)
                        }</span>
                }

        case *ast.InterfaceType:<span class="cov0" title="0">
                info.Kind = KindInterface
                info.Warning = "interface type - shallow copy only"</span>

        case *ast.ChanType:<span class="cov0" title="0">
                info.Kind = KindChan
                info.Warning = "channel type - not cloned"</span>

        case *ast.FuncType:<span class="cov0" title="0">
                info.Kind = KindFunc
                info.Warning = "function type - not cloned"</span>

        default:<span class="cov0" title="0">
                info.Kind = KindUnknown
                info.Warning = "unknown type - shallow copy"</span>
        }
}

// identKind returns the kind for an identifier
func (a *Analyzer) identKind(name string) FieldKind <span class="cov8" title="1">{
        switch name </span>{
        case "bool":<span class="cov8" title="1">
                return KindPrimitive</span>
        case "string":<span class="cov8" title="1">
                return KindString</span>
        case "int", "int8", "int16", "int32", "int64",
                "uint", "uint8", "uint16", "uint32", "uint64", "uintptr",
                "float32", "float64",
                "complex64", "complex128",
                "byte", "rune":<span class="cov8" title="1">
                return KindPrimitive</span>
        case "error":<span class="cov8" title="1">
                return KindInterface</span>
        case "any":<span class="cov8" title="1">
                return KindInterface</span>
        default:<span class="cov8" title="1">
                // Check if it's a struct in our package
                if _, ok := a.pkg.Structs[name]; ok </span><span class="cov8" title="1">{
                        return KindStruct
                }</span>
                // Assume it's a type alias or external type
                <span class="cov0" title="0">return KindStruct</span>
        }
}

// exprKind returns the kind for an expression
func (a *Analyzer) exprKind(expr ast.Expr) FieldKind <span class="cov8" title="1">{
        switch t := expr.(type) </span>{
        case *ast.Ident:<span class="cov8" title="1">
                return a.identKind(t.Name)</span>
        case *ast.SelectorExpr:<span class="cov0" title="0">
                typeStr := exprToString(t)
                if typeStr == "time.Time" || typeStr == "time.Duration" </span><span class="cov0" title="0">{
                        return KindTime
                }</span>
                <span class="cov0" title="0">return KindStruct</span>
        case *ast.StarExpr:<span class="cov0" title="0">
                return KindPointer</span>
        case *ast.ArrayType:<span class="cov8" title="1">
                if t.Len == nil </span><span class="cov8" title="1">{
                        return KindSlice
                }</span>
                <span class="cov0" title="0">return KindArray</span>
        case *ast.MapType:<span class="cov8" title="1">
                return KindMap</span>
        case *ast.InterfaceType:<span class="cov0" title="0">
                return KindInterface</span>
        case *ast.ChanType:<span class="cov0" title="0">
                return KindChan</span>
        case *ast.FuncType:<span class="cov0" title="0">
                return KindFunc</span>
        default:<span class="cov0" title="0">
                return KindUnknown</span>
        }
}

// exprToString converts an AST expression to its string representation
func exprToString(expr ast.Expr) string <span class="cov8" title="1">{
        switch t := expr.(type) </span>{
        case *ast.Ident:<span class="cov8" title="1">
                return t.Name</span>
        case *ast.SelectorExpr:<span class="cov8" title="1">
                return exprToString(t.X) + "." + t.Sel.Name</span>
        case *ast.StarExpr:<span class="cov8" title="1">
                return "*" + exprToString(t.X)</span>
        case *ast.ArrayType:<span class="cov8" title="1">
                if t.Len == nil </span><span class="cov8" title="1">{
                        return "[]" + exprToString(t.Elt)
                }</span>
                <span class="cov8" title="1">return "[" + exprToString(t.Len) + "]" + exprToString(t.Elt)</span>
        case *ast.MapType:<span class="cov8" title="1">
                return "map[" + exprToString(t.Key) + "]" + exprToString(t.Value)</span>
        case *ast.InterfaceType:<span class="cov0" title="0">
                if len(t.Methods.List) == 0 </span><span class="cov0" title="0">{
                        return "any"
                }</span>
                <span class="cov0" title="0">return "interface{...}"</span>
        case *ast.ChanType:<span class="cov0" title="0">
                switch t.Dir </span>{
                case ast.SEND:<span class="cov0" title="0">
                        return "chan&lt;- " + exprToString(t.Value)</span>
                case ast.RECV:<span class="cov0" title="0">
                        return "&lt;-chan " + exprToString(t.Value)</span>
                default:<span class="cov0" title="0">
                        return "chan " + exprToString(t.Value)</span>
                }
        case *ast.FuncType:<span class="cov0" title="0">
                return "func(...)"</span>
        case *ast.BasicLit:<span class="cov8" title="1">
                return t.Value</span>
        case *ast.Ellipsis:<span class="cov0" title="0">
                return "..." + exprToString(t.Elt)</span>
        case *ast.IndexExpr:<span class="cov0" title="0">
                // Generic type like Container[T]
                return exprToString(t.X) + "[" + exprToString(t.Index) + "]"</span>
        case *ast.IndexListExpr:<span class="cov0" title="0">
                // Generic type with multiple params
                var indices []string
                for _, idx := range t.Indices </span><span class="cov0" title="0">{
                        indices = append(indices, exprToString(idx))
                }</span>
                <span class="cov0" title="0">return exprToString(t.X) + "[" + strings.Join(indices, ", ") + "]"</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%T", expr)</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package statediff

import (
        "encoding/json"
        "fmt"
        "reflect"
        "sort"
)

// Patch is a list of operations (RFC 6902 JSON Patch compatible)
type Patch []Op

// Op represents a single patch operation
type Op struct {
        Op    string `json:"op"`              // "add", "remove", "replace"
        Path  string `json:"path"`            // JSON Pointer
        Value any    `json:"value,omitempty"` // New value
}

// JSON returns the patch as JSON bytes
func (p Patch) JSON() ([]byte, error) <span class="cov8" title="1">{
        if len(p) == 0 </span><span class="cov8" title="1">{
                return []byte("[]"), nil
        }</span>
        <span class="cov8" title="1">return json.Marshal(p)</span>
}

// Empty returns true if patch has no operations
func (p Patch) Empty() bool <span class="cov8" title="1">{
        return len(p) == 0
}</span>

// ArrayConfig configures array diff behavior
type ArrayConfig struct {
        Strategy ArrayStrategy
        KeyField string // For ByKey strategy
}

// ArrayStrategy determines how arrays are diffed
type ArrayStrategy int

const (
        ArrayReplace ArrayStrategy = iota // Replace entire array (default)
        ArrayByIndex                      // Diff per index
        ArrayByKey                        // Match by key field (NOTE: does not track order changes)
)

// calcDiff computes the diff between two values
func calcDiff[T any](old, new T, cfg ArrayConfig) (Patch, error) <span class="cov8" title="1">{
        oldData, err := json.Marshal(old)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">newData, err := json.Marshal(new)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var oldMap, newMap map[string]any
        if err := json.Unmarshal(oldData, &amp;oldMap); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unmarshal old state: %w", err)
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal(newData, &amp;newMap); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unmarshal new state: %w", err)
        }</span>

        <span class="cov8" title="1">return diffMaps("", oldMap, newMap, cfg), nil</span>
}

func diffMaps(path string, old, new map[string]any, cfg ArrayConfig) Patch <span class="cov8" title="1">{
        var ops Patch

        // Collect keys and sort for deterministic output
        // Map iteration order is random in Go - we must sort for consistent patches
        var oldKeys []string
        for k := range old </span><span class="cov8" title="1">{
                oldKeys = append(oldKeys, k)
        }</span>
        <span class="cov8" title="1">sort.Strings(oldKeys)

        var newKeys []string
        for k := range new </span><span class="cov8" title="1">{
                newKeys = append(newKeys, k)
        }</span>
        <span class="cov8" title="1">sort.Strings(newKeys)

        // Removed and changed (in sorted order)
        for _, k := range oldKeys </span><span class="cov8" title="1">{
                kPath := path + "/" + escapePtr(k)
                newV, exists := new[k]
                if !exists </span><span class="cov8" title="1">{
                        ops = append(ops, Op{Op: "remove", Path: kPath})
                }</span> else<span class="cov8" title="1"> {
                        ops = append(ops, diffValues(kPath, old[k], newV, cfg)...)
                }</span>
        }

        // Added (in sorted order)
        <span class="cov8" title="1">for _, k := range newKeys </span><span class="cov8" title="1">{
                if _, exists := old[k]; !exists </span><span class="cov8" title="1">{
                        ops = append(ops, Op{Op: "add", Path: path + "/" + escapePtr(k), Value: new[k]})
                }</span>
        }

        <span class="cov8" title="1">return ops</span>
}

func diffValues(path string, old, new any, cfg ArrayConfig) Patch <span class="cov8" title="1">{
        if reflect.DeepEqual(old, new) </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Type mismatch
        <span class="cov8" title="1">if reflect.TypeOf(old) != reflect.TypeOf(new) </span><span class="cov8" title="1">{
                return Patch{{Op: "replace", Path: path, Value: new}}
        }</span>

        // Nested object
        <span class="cov8" title="1">if oldMap, ok := old.(map[string]any); ok </span><span class="cov8" title="1">{
                return diffMaps(path, oldMap, new.(map[string]any), cfg)
        }</span>

        // Array
        <span class="cov8" title="1">if oldArr, ok := old.([]any); ok </span><span class="cov8" title="1">{
                return diffArrays(path, oldArr, new.([]any), cfg)
        }</span>

        // Primitive
        <span class="cov8" title="1">return Patch{{Op: "replace", Path: path, Value: new}}</span>
}

func diffArrays(path string, old, new []any, cfg ArrayConfig) Patch <span class="cov8" title="1">{
        switch cfg.Strategy </span>{
        case ArrayByIndex:<span class="cov8" title="1">
                return diffArraysByIndex(path, old, new, cfg)</span>
        case ArrayByKey:<span class="cov8" title="1">
                return diffArraysByKey(path, old, new, cfg)</span>
        default:<span class="cov8" title="1">
                if !reflect.DeepEqual(old, new) </span><span class="cov8" title="1">{
                        return Patch{{Op: "replace", Path: path, Value: new}}
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

func diffArraysByIndex(path string, old, new []any, cfg ArrayConfig) Patch <span class="cov8" title="1">{
        var ops Patch
        minLen := min(len(old), len(new))

        // Compare existing
        for i := 0; i &lt; minLen; i++ </span><span class="cov8" title="1">{
                ops = append(ops, diffValues(fmt.Sprintf("%s/%d", path, i), old[i], new[i], cfg)...)
        }</span>

        // Removed (from end)
        <span class="cov8" title="1">for i := len(old) - 1; i &gt;= minLen; i-- </span><span class="cov8" title="1">{
                ops = append(ops, Op{Op: "remove", Path: fmt.Sprintf("%s/%d", path, i)})
        }</span>

        // Added
        <span class="cov8" title="1">for i := minLen; i &lt; len(new); i++ </span><span class="cov8" title="1">{
                ops = append(ops, Op{Op: "add", Path: path + "/-", Value: new[i]})
        }</span>

        <span class="cov8" title="1">return ops</span>
}

func diffArraysByKey(path string, old, new []any, cfg ArrayConfig) Patch <span class="cov8" title="1">{
        if cfg.KeyField == "" </span><span class="cov8" title="1">{
                return Patch{{Op: "replace", Path: path, Value: new}}
        }</span>

        <span class="cov8" title="1">getKey := func(v any) (string, bool) </span><span class="cov8" title="1">{
                if m, ok := v.(map[string]any); ok </span><span class="cov8" title="1">{
                        if k, ok := m[cfg.KeyField]; ok </span><span class="cov8" title="1">{
                                return fmt.Sprint(k), true
                        }</span>
                }
                <span class="cov8" title="1">return "", false</span>
        }

        <span class="cov8" title="1">oldIdx := make(map[string]int)
        newIdx := make(map[string]int)

        for i, v := range old </span><span class="cov8" title="1">{
                if k, ok := getKey(v); ok </span><span class="cov8" title="1">{
                        oldIdx[k] = i
                }</span>
        }
        <span class="cov8" title="1">for i, v := range new </span><span class="cov8" title="1">{
                if k, ok := getKey(v); ok </span><span class="cov8" title="1">{
                        newIdx[k] = i
                }</span>
        }

        <span class="cov8" title="1">var ops Patch

        // Collect removed indices and sort descending
        // This is critical: JSON Patch operations are applied sequentially,
        // so removing index 0 before index 2 would shift indices incorrectly.
        var removedIndices []int
        for k, i := range oldIdx </span><span class="cov8" title="1">{
                if _, exists := newIdx[k]; !exists </span><span class="cov8" title="1">{
                        removedIndices = append(removedIndices, i)
                }</span>
        }
        <span class="cov8" title="1">sort.Sort(sort.Reverse(sort.IntSlice(removedIndices)))
        for _, i := range removedIndices </span><span class="cov8" title="1">{
                ops = append(ops, Op{Op: "remove", Path: fmt.Sprintf("%s/%d", path, i)})
        }</span>

        // Added and changed - iterate over 'new' slice (not map!) to preserve order
        // This is critical: map iteration order is random in Go, which would cause
        // non-deterministic patch order and corrupted client state.
        <span class="cov8" title="1">for ni, v := range new </span><span class="cov8" title="1">{
                k, hasKey := getKey(v)
                if !hasKey </span><span class="cov8" title="1">{
                        continue</span> // Skip elements without key field
                }

                <span class="cov8" title="1">if oi, existed := oldIdx[k]; !existed </span><span class="cov0" title="0">{
                        // New element - add to end
                        ops = append(ops, Op{Op: "add", Path: path + "/-", Value: v})
                }</span> else<span class="cov8" title="1"> {
                        // Existing element - use ni (new index) for the path
                        ops = append(ops, diffValues(fmt.Sprintf("%s/%d", path, ni), old[oi], new[ni], cfg)...)
                }</span>
        }

        <span class="cov8" title="1">return ops</span>
}

// escapePtr escapes JSON Pointer special chars
func escapePtr(s string) string <span class="cov8" title="1">{
        out := make([]byte, 0, len(s))
        for i := 0; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                switch s[i] </span>{
                case '~':<span class="cov8" title="1">
                        out = append(out, '~', '0')</span>
                case '/':<span class="cov8" title="1">
                        out = append(out, '~', '1')</span>
                default:<span class="cov8" title="1">
                        out = append(out, s[i])</span>
                }
        }
        <span class="cov8" title="1">return string(out)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package statediff

import (
        "sync"
        "time"
)

// Effect is a reversible state transformation.
// Effects don't mutate base state - they transform on read.
type Effect[T any] interface {
        ID() string
        Apply(T) T
}

// Func creates a simple effect from a function
func Func[T any](id string, fn func(T) T) Effect[T] <span class="cov8" title="1">{
        return &amp;funcEffect[T]{id: id, fn: fn}
}</span>

type funcEffect[T any] struct {
        id string
        fn func(T) T
}

func (e *funcEffect[T]) ID() string  <span class="cov8" title="1">{ return e.id }</span>
func (e *funcEffect[T]) Apply(s T) T <span class="cov8" title="1">{ return e.fn(s) }</span>

// Timed creates an effect that expires after duration.
// The effect is active immediately and expires after dur.
// Uses time.Now by default - set TimeFunc to nil to disable time checks,
// or provide a custom time function for testing.
func Timed[T any](id string, dur time.Duration, fn func(T) T) *TimedEffect[T] <span class="cov8" title="1">{
        now := time.Now()
        return &amp;TimedEffect[T]{
                id:        id,
                fn:        fn,
                startsAt:  now,
                expiresAt: now.Add(dur),
                TimeFunc:  time.Now,
        }
}</span>

// TimedWindow creates an effect that activates at startAt and expires at expiresAt.
// If startAt is zero, the effect is active immediately.
// If expiresAt is zero, the effect never expires (only startAt matters).
// Uses time.Now by default - set TimeFunc to nil to disable time checks,
// or provide a custom time function for testing.
func TimedWindow[T any](id string, startsAt, expiresAt time.Time, fn func(T) T) *TimedEffect[T] <span class="cov8" title="1">{
        return &amp;TimedEffect[T]{
                id:        id,
                fn:        fn,
                startsAt:  startsAt,
                expiresAt: expiresAt,
                TimeFunc:  time.Now,
        }
}</span>

// Delayed creates an effect that activates after delay and lasts for duration.
// Uses time.Now by default - set TimeFunc to nil to disable time checks,
// or provide a custom time function for testing.
func Delayed[T any](id string, delay, duration time.Duration, fn func(T) T) *TimedEffect[T] <span class="cov8" title="1">{
        now := time.Now()
        return &amp;TimedEffect[T]{
                id:        id,
                fn:        fn,
                startsAt:  now.Add(delay),
                expiresAt: now.Add(delay + duration),
                TimeFunc:  time.Now,
        }
}</span>

// TimedEffect is an effect with optional start time and expiration.
// The effect is only active between startsAt and expiresAt.
// Thread-safe: all methods can be called concurrently.
//
// Time handling: If TimeFunc is nil, time checks are skipped and the effect
// is always active. Set TimeFunc to time.Now for real-time behavior, or
// provide a custom function for deterministic/testable time.
type TimedEffect[T any] struct {
        mu        sync.RWMutex
        id        string
        fn        func(T) T
        startsAt  time.Time      // Zero means active immediately
        expiresAt time.Time      // Zero means never expires
        TimeFunc  func() time.Time // If nil, time checks are skipped
}

func (e *TimedEffect[T]) ID() string <span class="cov8" title="1">{ return e.id }</span>

func (e *TimedEffect[T]) Apply(s T) T <span class="cov8" title="1">{
        e.mu.RLock()
        startsAt := e.startsAt
        expiresAt := e.expiresAt
        timeFunc := e.TimeFunc
        e.mu.RUnlock()

        // If no time function provided, skip time checks (always active)
        if timeFunc == nil </span><span class="cov8" title="1">{
                return e.fn(s)
        }</span>

        <span class="cov8" title="1">now := timeFunc()

        // Check if not yet started
        if !startsAt.IsZero() &amp;&amp; now.Before(startsAt) </span><span class="cov8" title="1">{
                return s // Not yet active
        }</span>

        // Check if expired
        <span class="cov8" title="1">if !expiresAt.IsZero() &amp;&amp; now.After(expiresAt) </span><span class="cov8" title="1">{
                return s // Expired, no-op
        }</span>

        <span class="cov8" title="1">return e.fn(s)</span>
}

// Active returns true if the effect is currently active (started and not expired).
// Returns true if TimeFunc is nil (no time checks).
func (e *TimedEffect[T]) Active() bool <span class="cov8" title="1">{
        e.mu.RLock()
        startsAt := e.startsAt
        expiresAt := e.expiresAt
        timeFunc := e.TimeFunc
        e.mu.RUnlock()

        if timeFunc == nil </span><span class="cov8" title="1">{
                return true // No time checks, always active
        }</span>

        <span class="cov8" title="1">now := timeFunc()
        if !startsAt.IsZero() &amp;&amp; now.Before(startsAt) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if !expiresAt.IsZero() &amp;&amp; now.After(expiresAt) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// Started returns true if the effect has started (or startsAt is zero).
// Returns true if TimeFunc is nil (no time checks).
func (e *TimedEffect[T]) Started() bool <span class="cov8" title="1">{
        e.mu.RLock()
        startsAt := e.startsAt
        timeFunc := e.TimeFunc
        e.mu.RUnlock()

        if timeFunc == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return startsAt.IsZero() || !timeFunc().Before(startsAt)</span>
}

// Expired returns true if the effect has expired.
// Returns false if TimeFunc is nil (no time checks).
func (e *TimedEffect[T]) Expired() bool <span class="cov8" title="1">{
        e.mu.RLock()
        expiresAt := e.expiresAt
        timeFunc := e.TimeFunc
        e.mu.RUnlock()

        if timeFunc == nil </span><span class="cov8" title="1">{
                return false // No time checks, never expires
        }</span>
        <span class="cov8" title="1">return !expiresAt.IsZero() &amp;&amp; timeFunc().After(expiresAt)</span>
}

// Remaining returns the duration until expiration (0 if expired, no expiration, or no TimeFunc)
func (e *TimedEffect[T]) Remaining() time.Duration <span class="cov8" title="1">{
        e.mu.RLock()
        expiresAt := e.expiresAt
        timeFunc := e.TimeFunc
        e.mu.RUnlock()

        if timeFunc == nil || expiresAt.IsZero() </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">if r := expiresAt.Sub(timeFunc()); r &gt; 0 </span><span class="cov8" title="1">{
                return r
        }</span>
        <span class="cov8" title="1">return 0</span>
}

// UntilStart returns the duration until the effect starts (0 if already started or no TimeFunc)
func (e *TimedEffect[T]) UntilStart() time.Duration <span class="cov8" title="1">{
        e.mu.RLock()
        startsAt := e.startsAt
        timeFunc := e.TimeFunc
        e.mu.RUnlock()

        if timeFunc == nil || startsAt.IsZero() </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">if r := startsAt.Sub(timeFunc()); r &gt; 0 </span><span class="cov8" title="1">{
                return r
        }</span>
        <span class="cov8" title="1">return 0</span>
}

// Extend extends the expiration time by the given duration
func (e *TimedEffect[T]) Extend(d time.Duration) <span class="cov8" title="1">{
        e.mu.Lock()
        defer e.mu.Unlock()
        if e.expiresAt.IsZero() </span><span class="cov8" title="1">{
                return // No expiration to extend
        }</span>
        <span class="cov8" title="1">e.expiresAt = e.expiresAt.Add(d)</span>
}

// SetStartsAt changes the start time
func (e *TimedEffect[T]) SetStartsAt(t time.Time) <span class="cov8" title="1">{
        e.mu.Lock()
        defer e.mu.Unlock()
        e.startsAt = t
}</span>

// SetExpiresAt changes the expiration time
func (e *TimedEffect[T]) SetExpiresAt(t time.Time) <span class="cov8" title="1">{
        e.mu.Lock()
        defer e.mu.Unlock()
        e.expiresAt = t
}</span>

// Conditional creates an effect that only applies when condition is true
func Conditional[T any](id string, cond func(T) bool, fn func(T) T) Effect[T] <span class="cov8" title="1">{
        return &amp;condEffect[T]{id: id, cond: cond, fn: fn}
}</span>

type condEffect[T any] struct {
        id   string
        cond func(T) bool
        fn   func(T) T
}

func (e *condEffect[T]) ID() string <span class="cov8" title="1">{ return e.id }</span>

func (e *condEffect[T]) Apply(s T) T <span class="cov8" title="1">{
        if e.cond(s) </span><span class="cov8" title="1">{
                return e.fn(s)
        }</span>
        <span class="cov8" title="1">return s</span>
}

// Toggle creates an effect that can be enabled/disabled
func Toggle[T any](id string, fn func(T) T) *ToggleEffect[T] <span class="cov8" title="1">{
        return &amp;ToggleEffect[T]{id: id, fn: fn, enabled: true}
}</span>

// ToggleEffect can be switched on/off
type ToggleEffect[T any] struct {
        mu      sync.RWMutex
        id      string
        fn      func(T) T
        enabled bool
}

func (e *ToggleEffect[T]) ID() string <span class="cov8" title="1">{ return e.id }</span>

func (e *ToggleEffect[T]) Apply(s T) T <span class="cov8" title="1">{
        e.mu.RLock()
        defer e.mu.RUnlock()
        if e.enabled </span><span class="cov8" title="1">{
                return e.fn(s)
        }</span>
        <span class="cov8" title="1">return s</span>
}

func (e *ToggleEffect[T]) Enable() <span class="cov8" title="1">{
        e.mu.Lock()
        defer e.mu.Unlock()
        e.enabled = true
}</span>

func (e *ToggleEffect[T]) Disable() <span class="cov8" title="1">{
        e.mu.Lock()
        defer e.mu.Unlock()
        e.enabled = false
}</span>

func (e *ToggleEffect[T]) SetEnabled(b bool) <span class="cov8" title="1">{
        e.mu.Lock()
        defer e.mu.Unlock()
        e.enabled = b
}</span>

func (e *ToggleEffect[T]) IsEnabled() bool <span class="cov8" title="1">{
        e.mu.RLock()
        defer e.mu.RUnlock()
        return e.enabled
}</span>

// Stack creates a stackable effect where multiple values combine
func Stack[T any, V any](id string, combine func(T, []V) T) *StackEffect[T, V] <span class="cov8" title="1">{
        return &amp;StackEffect[T, V]{id: id, combine: combine}
}</span>

// StackEffect accumulates values
type StackEffect[T any, V any] struct {
        mu      sync.RWMutex
        id      string
        values  []V
        combine func(T, []V) T
}

func (e *StackEffect[T, V]) ID() string <span class="cov8" title="1">{ return e.id }</span>

func (e *StackEffect[T, V]) Apply(s T) T <span class="cov8" title="1">{
        e.mu.RLock()
        defer e.mu.RUnlock()
        if len(e.values) == 0 </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">return e.combine(s, e.values)</span>
}

func (e *StackEffect[T, V]) Push(v V) <span class="cov8" title="1">{
        e.mu.Lock()
        defer e.mu.Unlock()
        e.values = append(e.values, v)
}</span>

func (e *StackEffect[T, V]) Pop() (V, bool) <span class="cov8" title="1">{
        e.mu.Lock()
        defer e.mu.Unlock()
        if len(e.values) == 0 </span><span class="cov8" title="1">{
                var zero V
                return zero, false
        }</span>
        <span class="cov8" title="1">v := e.values[len(e.values)-1]
        e.values = e.values[:len(e.values)-1]
        return v, true</span>
}

func (e *StackEffect[T, V]) Clear() <span class="cov8" title="1">{
        e.mu.Lock()
        defer e.mu.Unlock()
        e.values = nil
}</span>

func (e *StackEffect[T, V]) Count() int <span class="cov8" title="1">{
        e.mu.RLock()
        defer e.mu.RUnlock()
        return len(e.values)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/mxkacsa/statediff"
)

// Game state
type Game struct {
        Round   int      `json:"round"`
        Phase   string   `json:"phase"`
        Players []Player `json:"players"`
}

type Player struct {
        ID    string `json:"id"`
        Name  string `json:"name"`
        Score int    `json:"score"`
        Hand  []int  `json:"hand,omitempty"` // Hidden from others
}

// Clone for performance (optional but ~40x faster)
func (g Game) Clone() Game <span class="cov0" title="0">{
        c := Game{Round: g.Round, Phase: g.Phase, Players: make([]Player, len(g.Players))}
        for i, p := range g.Players </span><span class="cov0" title="0">{
                c.Players[i] = Player{ID: p.ID, Name: p.Name, Score: p.Score, Hand: append([]int{}, p.Hand...)}
        }</span>
        <span class="cov0" title="0">return c</span>
}

func main() <span class="cov0" title="0">{
        fmt.Println("=== StateDiff Demo ===")
        fmt.Println()

        // Create state with custom cloner
        state, err := statediff.New(Game{
                Round: 1,
                Phase: "lobby",
                Players: []Player{
                        {ID: "alice", Name: "Alice", Score: 0, Hand: []int{1, 2, 3}},
                        {ID: "bob", Name: "Bob", Score: 0, Hand: []int{4, 5, 6}},
                },
        }, &amp;statediff.Config[Game]{
                Cloner: func(g Game) Game </span><span class="cov0" title="0">{ return g.Clone() }</span>,
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        // Create session manager
        <span class="cov0" title="0">session := statediff.NewSession[Game, string](state)

        // Players connect with their projection (hides other hands)
        for _, id := range []string{"alice", "bob"} </span><span class="cov0" title="0">{
                pid := id // capture
                session.Connect(id, func(g Game) Game </span><span class="cov0" title="0">{
                        result := g.Clone()
                        for i := range result.Players </span><span class="cov0" title="0">{
                                if result.Players[i].ID != pid </span><span class="cov0" title="0">{
                                        result.Players[i].Hand = nil
                                }</span>
                        }
                        <span class="cov0" title="0">return result</span>
                })
        }

        // Initial sync - full state
        <span class="cov0" title="0">fmt.Println("--- Initial sync ---")
        for _, id := range []string{"alice", "bob"} </span><span class="cov0" title="0">{
                data, _ := session.Full(id)
                fmt.Printf("%s: %s\n", id, truncate(string(data)))
        }</span>

        // Game starts
        <span class="cov0" title="0">fmt.Println("\n--- Game starts ---")
        state.Update(func(g *Game) </span><span class="cov0" title="0">{
                g.Phase = "playing"
                g.Players[0].Score = 100
        }</span>)

        // Broadcast diffs
        <span class="cov0" title="0">for id, data := range session.Tick() </span><span class="cov0" title="0">{
                fmt.Printf("%s: %s\n", id, truncate(string(data)))
        }</span>

        // Add timed effect (double score for 5 seconds)
        <span class="cov0" title="0">fmt.Println("\n--- Double score effect (5s) ---")
        doubleScore := statediff.Timed("double", 5*time.Second, func(g Game) Game </span><span class="cov0" title="0">{
                for i := range g.Players </span><span class="cov0" title="0">{
                        g.Players[i].Score *= 2
                }</span>
                <span class="cov0" title="0">return g</span>
        })
        <span class="cov0" title="0">state.AddEffect(doubleScore)

        for id, data := range session.Tick() </span><span class="cov0" title="0">{
                fmt.Printf("%s: %s\n", id, truncate(string(data)))
        }</span>

        // Check current values
        <span class="cov0" title="0">fmt.Println("\n--- Current state (with effect) ---")
        current := state.Get()
        fmt.Printf("Alice score: %d (base: 100, with 2x: 200)\n", current.Players[0].Score)

        // Remove effect
        fmt.Println("\n--- Remove effect ---")
        state.RemoveEffect("double")
        for id, data := range session.Tick() </span><span class="cov0" title="0">{
                fmt.Printf("%s: %s\n", id, truncate(string(data)))
        }</span>

        // Stacking multipliers
        <span class="cov0" title="0">fmt.Println("\n--- Stacking multipliers ---")
        multipliers := statediff.Stack[Game, float64]("mult", func(g Game, mults []float64) Game </span><span class="cov0" title="0">{
                total := 1.0
                for _, m := range mults </span><span class="cov0" title="0">{
                        total *= m
                }</span>
                <span class="cov0" title="0">for i := range g.Players </span><span class="cov0" title="0">{
                        g.Players[i].Score = int(float64(g.Players[i].Score) * total)
                }</span>
                <span class="cov0" title="0">return g</span>
        })
        <span class="cov0" title="0">state.AddEffect(multipliers)
        session.Tick() // Clear

        multipliers.Push(1.5)
        state.Update(func(g *Game) </span>{<span class="cov0" title="0">}</span>) // Trigger change detection
        <span class="cov0" title="0">fmt.Printf("With 1.5x: Alice=%d\n", state.Get().Players[0].Score)

        multipliers.Push(2.0)
        state.Update(func(g *Game) </span>{<span class="cov0" title="0">}</span>)
        <span class="cov0" title="0">fmt.Printf("With 1.5x * 2x: Alice=%d\n", state.Get().Players[0].Score)

        multipliers.Pop()
        state.Update(func(g *Game) </span>{<span class="cov0" title="0">}</span>)
        <span class="cov0" title="0">fmt.Printf("After pop: Alice=%d\n", state.Get().Players[0].Score)

        // Save for restart
        fmt.Println("\n--- Save state ---")
        effectMeta, _ := statediff.MakeEffectMeta("mult", "multiplier", nil)
        effects := []statediff.EffectMeta{effectMeta}
        savePath := filepath.Join(os.TempDir(), "game.json")
        err = statediff.Save(savePath, state, effects, nil)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Save error: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Saved to %s\n", savePath)
        }</span>

        // Load (simulating restart)
        <span class="cov0" title="0">fmt.Println("\n--- Load state ---")
        snap, _ := statediff.Load[Game](savePath)
        if snap != nil </span><span class="cov0" title="0">{
                fmt.Printf("Loaded: Round=%d, Phase=%s, SavedAt=%s\n",
                        snap.State.Round, snap.State.Phase, snap.SavedAt.Format(time.RFC3339))
        }</span>

        <span class="cov0" title="0">fmt.Println("\n=== Done ===")</span>
}

func truncate(s string) string <span class="cov0" title="0">{
        if len(s) &gt; 120 </span><span class="cov0" title="0">{
                return s[:120] + "..."
        }</span>
        <span class="cov0" title="0">return s</span>
}

// prettyJSON formats JSON for display
func prettyJSON(v any) string <span class="cov0" title="0">{
        data, _ := json.MarshalIndent(v, "", "  ")
        return string(data)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package statediff

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "time"
)

// Snapshot represents saved state that can be restored
type Snapshot[T any] struct {
        Version   int              `json:"version"`           // Schema version for forward compatibility
        State     T                `json:"state"`
        Effects   []EffectMeta     `json:"effects,omitempty"`
        SavedAt   time.Time        `json:"savedAt"`
        Extra     json.RawMessage  `json:"extra,omitempty"`
}

// Current snapshot version
const SnapshotVersion = 1

// RestoreResult contains the restored state and any non-fatal errors
type RestoreResult[T any] struct {
        State        *State[T]
        EffectErrors []error // Errors from effect factory (non-fatal)
}

// EffectMeta stores effect info for recreation
type EffectMeta struct {
        ID     string          `json:"id"`
        Type   string          `json:"type"`
        Params json.RawMessage `json:"params,omitempty"`
}

// EffectFactory recreates effects from metadata
type EffectFactory[T any] func(meta EffectMeta) (Effect[T], error)

// Save writes state to a JSON file (atomic write)
func Save[T any](path string, state *State[T], effects []EffectMeta, extra any) error <span class="cov8" title="1">{
        var extraJSON json.RawMessage
        if extra != nil </span><span class="cov8" title="1">{
                var err error
                extraJSON, err = json.Marshal(extra)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("marshal extra: %w", err)
                }</span>
        }

        <span class="cov8" title="1">snap := Snapshot[T]{
                Version: SnapshotVersion,
                State:   state.GetBase(),
                Effects: effects,
                SavedAt: time.Now(),
                Extra:   extraJSON,
        }

        data, err := json.MarshalIndent(snap, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshal: %w", err)
        }</span>

        // Atomic write: temp file + rename
        <span class="cov8" title="1">dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("mkdir: %w", err)
        }</span>

        <span class="cov8" title="1">tmp := path + ".tmp"
        if err := os.WriteFile(tmp, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write: %w", err)
        }</span>

        <span class="cov8" title="1">if err := os.Rename(tmp, path); err != nil </span><span class="cov0" title="0">{
                os.Remove(tmp)
                return fmt.Errorf("rename: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Load reads state from a JSON file
func Load[T any](path string) (*Snapshot[T], error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return nil, nil // No saved state
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("read: %w", err)</span>
        }

        <span class="cov8" title="1">var snap Snapshot[T]
        if err := json.Unmarshal(data, &amp;snap); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("unmarshal: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;snap, nil</span>
}

// Restore loads state and recreates effects.
// Returns RestoreResult which includes both the state and any effect recreation errors.
// Effect errors are non-fatal - the state is still returned with successfully recreated effects.
func Restore[T any](path string, cfg *Config[T], factory EffectFactory[T]) (*RestoreResult[T], error) <span class="cov8" title="1">{
        snap, err := Load[T](path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if snap == nil </span><span class="cov8" title="1">{
                return nil, nil // No saved state
        }</span>

        <span class="cov8" title="1">state, err := New(snap.State, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create state: %w", err)
        }</span>
        <span class="cov8" title="1">result := &amp;RestoreResult[T]{State: state}

        // Recreate effects
        if factory != nil </span><span class="cov8" title="1">{
                for _, meta := range snap.Effects </span><span class="cov8" title="1">{
                        effect, err := factory(meta)
                        if err != nil </span><span class="cov8" title="1">{
                                result.EffectErrors = append(result.EffectErrors,
                                        fmt.Errorf("effect %q (type %s): %w", meta.ID, meta.Type, err))
                                continue</span>
                        }
                        <span class="cov8" title="1">if effect != nil </span><span class="cov8" title="1">{
                                if err := state.AddEffect(effect); err != nil </span><span class="cov8" title="1">{
                                        result.EffectErrors = append(result.EffectErrors, err)
                                        continue</span>
                                }
                        }
                }
                // Clear the "previous" state that AddEffect created
                <span class="cov8" title="1">state.ClearPrevious()</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// MakeEffectMeta creates metadata for an effect.
// Returns an error if params cannot be marshaled to JSON.
func MakeEffectMeta(id, typ string, params any) (EffectMeta, error) <span class="cov8" title="1">{
        var p json.RawMessage
        if params != nil </span><span class="cov8" title="1">{
                var err error
                p, err = json.Marshal(params)
                if err != nil </span><span class="cov8" title="1">{
                        return EffectMeta{}, fmt.Errorf("statediff: failed to marshal effect params: %w", err)
                }</span>
        }
        <span class="cov8" title="1">return EffectMeta{ID: id, Type: typ, Params: p}, nil</span>
}

// ParseParams unmarshals effect params
func ParseParams[P any](meta EffectMeta) (P, error) <span class="cov8" title="1">{
        var p P
        if len(meta.Params) &gt; 0 </span><span class="cov8" title="1">{
                err := json.Unmarshal(meta.Params, &amp;p)
                return p, err
        }</span>
        <span class="cov8" title="1">return p, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package statediff

import (
        "encoding/json"
        "sync"
)

// Session manages multiple client connections.
// Each client has a projection function that determines what they see.
type Session[T any, ID comparable] struct {
        mu      sync.RWMutex
        state   *State[T]
        clients map[ID]func(T) T // ID -&gt; projection function
}

// NewSession creates a session manager for the given state
func NewSession[T any, ID comparable](state *State[T]) *Session[T, ID] <span class="cov8" title="1">{
        return &amp;Session[T, ID]{
                state:   state,
                clients: make(map[ID]func(T) T),
        }
}</span>

// Connect registers a client with their projection function.
// Projection can be nil if client sees full state.
func (s *Session[T, ID]) Connect(id ID, project func(T) T) <span class="cov8" title="1">{
        s.mu.Lock()
        s.clients[id] = project
        s.mu.Unlock()
}</span>

// Disconnect removes a client
func (s *Session[T, ID]) Disconnect(id ID) <span class="cov8" title="1">{
        s.mu.Lock()
        delete(s.clients, id)
        s.mu.Unlock()
}</span>

// IsConnected checks if a client is registered
func (s *Session[T, ID]) IsConnected(id ID) bool <span class="cov8" title="1">{
        s.mu.RLock()
        _, ok := s.clients[id]
        s.mu.RUnlock()
        return ok
}</span>

// Count returns number of connected clients
func (s *Session[T, ID]) Count() int <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return len(s.clients)
}</span>

// IDs returns all connected client IDs
func (s *Session[T, ID]) IDs() []ID <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        ids := make([]ID, 0, len(s.clients))
        for id := range s.clients </span><span class="cov8" title="1">{
                ids = append(ids, id)
        }</span>
        <span class="cov8" title="1">return ids</span>
}

// Full returns the full state for a client (for initial sync).
// Thread-safe: holds lock during state access to prevent races.
func (s *Session[T, ID]) Full(id ID) ([]byte, error) <span class="cov8" title="1">{
        s.mu.RLock()
        project := s.clients[id]
        state := s.state.FullState(project)
        s.mu.RUnlock()

        // Wrap as replace operation
        patch := Patch{{Op: "replace", Path: "", Value: state}}
        return json.Marshal(patch)
}</span>

// Diff returns the diff for a client since last change.
// Thread-safe: holds lock during diff calculation to prevent races.
func (s *Session[T, ID]) Diff(id ID) ([]byte, error) <span class="cov8" title="1">{
        s.mu.RLock()
        project := s.clients[id]
        patch, err := s.state.Diff(project)
        s.mu.RUnlock()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if patch == nil || patch.Empty() </span><span class="cov8" title="1">{
                return []byte("[]"), nil
        }</span>
        <span class="cov8" title="1">return patch.JSON()</span>
}

// Broadcast returns diffs for all connected clients.
// Only includes clients with actual changes.
// Optimized: caches the diff for clients with nil projection (full state view).
func (s *Session[T, ID]) Broadcast() map[ID][]byte <span class="cov8" title="1">{
        if !s.state.HasChanges() </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">s.mu.RLock()
        defer s.mu.RUnlock()

        result := make(map[ID][]byte, len(s.clients))

        // Cache for nil projection (full state view) - computed once, reused for all
        var fullDiff []byte
        var fullDiffComputed bool

        for id, project := range s.clients </span><span class="cov8" title="1">{
                var data []byte

                if project == nil </span><span class="cov8" title="1">{
                        // Use cached full diff
                        if !fullDiffComputed </span><span class="cov8" title="1">{
                                patch, err := s.state.Diff(nil)
                                if err != nil || patch.Empty() </span><span class="cov0" title="0">{
                                        fullDiff = nil
                                }</span> else<span class="cov8" title="1"> {
                                        fullDiff, _ = patch.JSON()
                                }</span>
                                <span class="cov8" title="1">fullDiffComputed = true</span>
                        }
                        <span class="cov8" title="1">data = fullDiff</span>
                } else<span class="cov8" title="1"> {
                        // Compute individual diff for custom projection
                        patch, err := s.state.Diff(project)
                        if err != nil || patch.Empty() </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">data, _ = patch.JSON()</span>
                }

                <span class="cov8" title="1">if data != nil </span><span class="cov8" title="1">{
                        result[id] = data
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// Tick cleans up expired effects, broadcasts changes, and clears previous state.
// This is the recommended way to use the library - just call Tick() after state updates.
// Typical game loop: Update state -&gt; Tick -&gt; Send to clients
func (s *Session[T, ID]) Tick() map[ID][]byte <span class="cov8" title="1">{
        s.state.CleanupExpired() // Automatically handle expired effects
        result := s.Broadcast()
        s.state.ClearPrevious()
        return result
}</span>

// State returns the underlying state for modifications
func (s *Session[T, ID]) State() *State[T] <span class="cov8" title="1">{
        return s.state
}</span>

</pre>
		
		<pre class="file" id="file9" style="display: none">// Package statediff provides deterministic state synchronization with automatic
// JSON diff generation, reversible effects, and player-specific projections.
//
// Key design principles:
//   - Deterministic: same inputs always produce same outputs
//   - Minimal memory: only stores one previous state, not per-session
//   - Projection-based: each viewer sees a filtered view of the state
//   - Effect system: reversible transformations that don't mutate base state
package statediff

import (
        "encoding/json"
        "fmt"
        "sync"
)

// State manages game state with effects and projections.
// Thread-safe for concurrent access.
type State[T any] struct {
        mu sync.RWMutex

        current  T       // Current base state
        previous T       // Previous state (with effects) for diff calculation
        hasPrevi bool    // Whether previous is valid
        effects  []Effect[T]
        cloner   func(T) T
        arrayCfg ArrayConfig
}

// Config for State initialization
type Config[T any] struct {
        // Cloner for deep copies. If nil, uses JSON marshal/unmarshal.
        // Implementing a manual cloner is ~40x faster.
        Cloner func(T) T

        // ArrayStrategy configures how array diffs are calculated
        ArrayStrategy ArrayStrategy
        // ArrayKeyField is the field name used as ID when ArrayStrategy is ByKey
        ArrayKeyField string
}

// New creates a new State with the given initial value.
// Returns an error if the configuration is invalid or the state type cannot be serialized.
func New[T any](initial T, cfg *Config[T]) (*State[T], error) <span class="cov8" title="1">{
        s := &amp;State[T]{current: initial}
        if cfg != nil </span><span class="cov8" title="1">{
                s.cloner = cfg.Cloner
                s.arrayCfg = ArrayConfig{Strategy: cfg.ArrayStrategy, KeyField: cfg.ArrayKeyField}

                // Validate ArrayConfig
                if cfg.ArrayStrategy == ArrayByKey &amp;&amp; cfg.ArrayKeyField == "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("statediff: ArrayByKey strategy requires ArrayKeyField to be set")
                }</span>
        }

        // Validate that state type can be JSON serialized (only if no custom cloner)
        <span class="cov8" title="1">if s.cloner == nil </span><span class="cov8" title="1">{
                data, err := json.Marshal(initial)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("statediff: state type cannot be JSON marshaled: %w", err)
                }</span>
                <span class="cov8" title="1">var test T
                if err := json.Unmarshal(data, &amp;test); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("statediff: state type cannot be JSON unmarshaled: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return s, nil</span>
}

// MustNew creates a new State, panicking if there's an error.
// Use New() for error handling in production code.
func MustNew[T any](initial T, cfg *Config[T]) *State[T] <span class="cov8" title="1">{
        s, err := New(initial, cfg)
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return s</span>
}

// clone creates a deep copy.
// If no custom cloner is set, uses JSON marshal/unmarshal (slower but universal).
// Note: New() validates that the type can be serialized, so errors here indicate
// a bug (e.g., state was modified to include unserializable fields).
func (s *State[T]) clone(src T) T <span class="cov8" title="1">{
        if s.cloner != nil </span><span class="cov8" title="1">{
                return s.cloner(src)
        }</span>
        <span class="cov8" title="1">var dst T
        data, err := json.Marshal(src)
        if err != nil </span><span class="cov0" title="0">{
                // This shouldn't happen if New() validated the type correctly.
                // Panic because silent failure would cause diff corruption.
                panic(fmt.Sprintf("statediff: clone marshal failed (type changed after New?): %v", err))</span>
        }
        <span class="cov8" title="1">if err := json.Unmarshal(data, &amp;dst); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("statediff: clone unmarshal failed: %v", err))</span>
        }
        <span class="cov8" title="1">return dst</span>
}

// withEffects returns state with all effects applied
func (s *State[T]) withEffects(state T) T <span class="cov8" title="1">{
        result := s.clone(state)
        for _, e := range s.effects </span><span class="cov8" title="1">{
                result = e.Apply(result)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// Get returns current state with effects applied
func (s *State[T]) Get() T <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.withEffects(s.current)
}</span>

// GetBase returns current state without effects
func (s *State[T]) GetBase() T <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.clone(s.current)
}</span>

// Update modifies the state. Saves previous for diff calculation.
func (s *State[T]) Update(fn func(*T)) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.previous = s.withEffects(s.current)
        s.hasPrevi = true
        fn(&amp;s.current)
}</span>

// Set replaces the entire state
func (s *State[T]) Set(newState T) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.previous = s.withEffects(s.current)
        s.hasPrevi = true
        s.current = s.clone(newState)
}</span>

// AddEffect adds a reversible effect.
// Returns an error if an effect with the same ID already exists.
func (s *State[T]) AddEffect(e Effect[T]) error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Check for duplicate ID
        for _, existing := range s.effects </span><span class="cov8" title="1">{
                if existing.ID() == e.ID() </span><span class="cov8" title="1">{
                        return fmt.Errorf("statediff: effect with ID %q already exists", e.ID())
                }</span>
        }

        <span class="cov8" title="1">s.previous = s.withEffects(s.current)
        s.hasPrevi = true
        s.effects = append(s.effects, e)
        return nil</span>
}

// RemoveEffect removes an effect by ID
func (s *State[T]) RemoveEffect(id string) bool <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        for i, e := range s.effects </span><span class="cov8" title="1">{
                if e.ID() == id </span><span class="cov8" title="1">{
                        s.previous = s.withEffects(s.current)
                        s.hasPrevi = true
                        s.effects = append(s.effects[:i], s.effects[i+1:]...)
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// HasEffect checks if an effect is active
func (s *State[T]) HasEffect(id string) bool <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        for _, e := range s.effects </span><span class="cov8" title="1">{
                if e.ID() == id </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// ClearEffects removes all effects
func (s *State[T]) ClearEffects() <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        if len(s.effects) &gt; 0 </span><span class="cov8" title="1">{
                s.previous = s.withEffects(s.current)
                s.hasPrevi = true
                s.effects = nil
        }</span>
}

// Diff calculates diff between previous and current state for a viewer.
// If no previous state exists, returns nil (caller should send full state).
func (s *State[T]) Diff(project func(T) T) (Patch, error) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        if !s.hasPrevi </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">current := s.withEffects(s.current)

        oldProj := s.previous
        newProj := current
        if project != nil </span><span class="cov8" title="1">{
                oldProj = project(s.previous)
                newProj = project(current)
        }</span>

        <span class="cov8" title="1">return calcDiff(oldProj, newProj, s.arrayCfg)</span>
}

// FullState returns the complete state for a viewer (for initial sync)
func (s *State[T]) FullState(project func(T) T) T <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        current := s.withEffects(s.current)
        if project != nil </span><span class="cov8" title="1">{
                return project(current)
        }</span>
        <span class="cov8" title="1">return current</span>
}

// ClearPrevious clears the previous state.
// Call after broadcasting to all clients.
func (s *State[T]) ClearPrevious() <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.hasPrevi = false
}</span>

// HasChanges returns true if there are changes to broadcast
func (s *State[T]) HasChanges() bool <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.hasPrevi
}</span>

// GetEffect returns an effect by ID, or nil if not found
func (s *State[T]) GetEffect(id string) Effect[T] <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        for _, e := range s.effects </span><span class="cov8" title="1">{
                if e.ID() == id </span><span class="cov8" title="1">{
                        return e
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Effects returns a copy of all active effects
func (s *State[T]) Effects() []Effect[T] <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        if len(s.effects) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return append([]Effect[T]{}, s.effects...)</span>
}

// Expirable interface for effects that can expire
type Expirable interface {
        Expired() bool
}

// CleanupExpired removes all expired effects.
// Returns the number of effects removed.
func (s *State[T]) CleanupExpired() int <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if len(s.effects) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        // Check if any effects are expirable and expired
        <span class="cov8" title="1">hasExpired := false
        for _, e := range s.effects </span><span class="cov8" title="1">{
                if exp, ok := e.(Expirable); ok &amp;&amp; exp.Expired() </span><span class="cov8" title="1">{
                        hasExpired = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !hasExpired </span><span class="cov8" title="1">{
                return 0
        }</span>

        // Only save previous state if there's no pending change already.
        // If hasPrevi is true, an Update() happened this cycle and we must NOT
        // overwrite previous, or we'll lose the state change diff.
        <span class="cov8" title="1">if !s.hasPrevi </span><span class="cov8" title="1">{
                s.previous = s.withEffects(s.current)
                s.hasPrevi = true
        }</span>

        // Filter out expired effects
        <span class="cov8" title="1">removed := 0
        active := s.effects[:0]
        for _, e := range s.effects </span><span class="cov8" title="1">{
                if exp, ok := e.(Expirable); ok &amp;&amp; exp.Expired() </span><span class="cov8" title="1">{
                        removed++
                        continue</span>
                }
                <span class="cov8" title="1">active = append(active, e)</span>
        }
        <span class="cov8" title="1">s.effects = active

        return removed</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
