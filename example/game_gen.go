// Code generated by schemagen. DO NOT EDIT.

package main

import (
	"sync"

	"github.com/mxkacsa/statesync"
)

// Player is a tracked state type
type Player struct {
	mu      sync.RWMutex
	changes *statesync.ChangeSet
	schema  *statesync.Schema

	id    string
	name  string
	score int64
	hand  []int32
	ready bool
}

// NewPlayer creates a new Player
func NewPlayer() *Player {
	return &Player{
		changes: statesync.NewChangeSet(),
		schema:  PlayerSchema(),
	}
}

// PlayerSchema returns the schema for Player
func PlayerSchema() *statesync.Schema {
	return statesync.NewSchemaBuilder("Player").
		WithID(2).String("ID").String("Name").Int64("Score").
		Array("Hand", statesync.TypeInt32, nil).Bool("Ready").
		Build()
}

// Trackable implementation

func (t *Player) Schema() *statesync.Schema     { return t.schema }
func (t *Player) Changes() *statesync.ChangeSet { return t.changes }
func (t *Player) ClearChanges()                 { t.changes.Clear() }
func (t *Player) MarkAllDirty()                 { t.changes.MarkAll(4) }

func (t *Player) GetFieldValue(index uint8) interface{} {
	t.mu.RLock()
	defer t.mu.RUnlock()
	switch index {
	case 0:
		return t.id
	case 1:
		return t.name
	case 2:
		return t.score
	case 3:
		return t.hand
	case 4:
		return t.ready
	}
	return nil
}

// FastEncoder implementation - zero allocation encoding

func (t *Player) EncodeChangesTo(e *statesync.Encoder) {
	t.mu.RLock()
	defer t.mu.RUnlock()

	// Count and write number of changes
	changes := t.changes
	count := 0
	if changes.IsFieldDirty(0) {
		count++
	}
	if changes.IsFieldDirty(1) {
		count++
	}
	if changes.IsFieldDirty(2) {
		count++
	}
	if changes.IsFieldDirty(3) {
		count++
	}
	if changes.IsFieldDirty(4) {
		count++
	}
	e.WriteChangeCount(count)

	// Encode each changed field directly (no interface{} boxing)
	if changes.IsFieldDirty(0) {
		e.WriteFieldHeader(0, statesync.OpReplace)
		e.WriteString(t.id)
	}
	if changes.IsFieldDirty(1) {
		e.WriteFieldHeader(1, statesync.OpReplace)
		e.WriteString(t.name)
	}
	if changes.IsFieldDirty(2) {
		e.WriteFieldHeader(2, statesync.OpReplace)
		e.WriteInt64(t.score)
	}
	if changes.IsFieldDirty(3) {
		e.WriteFieldHeader(3, statesync.OpReplace)
		// Complex type - TODO: handle arrays/maps/structs
	}
	if changes.IsFieldDirty(4) {
		e.WriteFieldHeader(4, statesync.OpReplace)
		e.WriteBool(t.ready)
	}
}

func (t *Player) EncodeAllTo(e *statesync.Encoder) {
	t.mu.RLock()
	defer t.mu.RUnlock()

	// Encode all fields directly (no interface{} boxing)
	e.WriteString(t.id)
	e.WriteString(t.name)
	e.WriteInt64(t.score)
	// Complex type field Hand - TODO: handle arrays/maps/structs
	e.WriteBool(t.ready)
}

// Getters and Setters

// ID returns the current value
func (t *Player) ID() string {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.id
}

// SetID sets the value and marks it as changed
func (t *Player) SetID(v string) {
	t.mu.Lock()
	defer t.mu.Unlock()

	if t.id != v {
		t.id = v
		t.changes.Mark(0, statesync.OpReplace)
	}

}

// Name returns the current value
func (t *Player) Name() string {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.name
}

// SetName sets the value and marks it as changed
func (t *Player) SetName(v string) {
	t.mu.Lock()
	defer t.mu.Unlock()

	if t.name != v {
		t.name = v
		t.changes.Mark(1, statesync.OpReplace)
	}

}

// Score returns the current value
func (t *Player) Score() int64 {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.score
}

// SetScore sets the value and marks it as changed
func (t *Player) SetScore(v int64) {
	t.mu.Lock()
	defer t.mu.Unlock()

	if t.score != v {
		t.score = v
		t.changes.Mark(2, statesync.OpReplace)
	}

}

// Hand returns the current value
func (t *Player) Hand() []int32 {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.hand
}

// SetHand replaces the entire slice
func (t *Player) SetHand(v []int32) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.hand = v
	t.changes.Mark(3, statesync.OpReplace)
}

// AppendHand adds an element to the slice
func (t *Player) AppendHand(v int32) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.hand = append(t.hand, v)
	arr := t.changes.GetOrCreateArray(3)
	arr.MarkAdd(len(t.hand)-1, v)
}

// RemoveHandAt removes an element at index
func (t *Player) RemoveHandAt(index int) {
	t.mu.Lock()
	defer t.mu.Unlock()
	if index >= 0 && index < len(t.hand) {
		t.hand = append(t.hand[:index], t.hand[index+1:]...)
		arr := t.changes.GetOrCreateArray(3)
		arr.MarkRemove(index)
	}
}

// UpdateHandAt updates an element at index
func (t *Player) UpdateHandAt(index int, v int32) {
	t.mu.Lock()
	defer t.mu.Unlock()
	if index >= 0 && index < len(t.hand) {
		t.hand[index] = v
		arr := t.changes.GetOrCreateArray(3)
		arr.MarkReplace(index, v)
	}
}

// HandLen returns the length of the slice
func (t *Player) HandLen() int {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return len(t.hand)
}

// HandAt returns the element at index
func (t *Player) HandAt(index int) int32 {
	t.mu.RLock()
	defer t.mu.RUnlock()
	if index >= 0 && index < len(t.hand) {
		return t.hand[index]
	}
	var zero int32
	return zero
}

// Ready returns the current value
func (t *Player) Ready() bool {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.ready
}

// SetReady sets the value and marks it as changed
func (t *Player) SetReady(v bool) {
	t.mu.Lock()
	defer t.mu.Unlock()

	if t.ready != v {
		t.ready = v
		t.changes.Mark(4, statesync.OpReplace)
	}

}

// GameState is a tracked state type
type GameState struct {
	mu      sync.RWMutex
	changes *statesync.ChangeSet
	schema  *statesync.Schema

	round      int32
	phase      string
	players    []Player
	scores     map[string]int64
	secretseed int64
}

// NewGameState creates a new GameState
func NewGameState() *GameState {
	return &GameState{
		changes: statesync.NewChangeSet(),
		schema:  GameStateSchema(),
	}
}

// GameStateSchema returns the schema for GameState
func GameStateSchema() *statesync.Schema {
	return statesync.NewSchemaBuilder("GameState").
		WithID(1).Int32("Round").String("Phase").
		ArrayByKey("Players", statesync.TypeStruct, PlayerSchema(), "ID").
		Map("Scores", statesync.TypeInt64, nil).Int64("SecretSeed").
		Build()
}

// Trackable implementation

func (t *GameState) Schema() *statesync.Schema     { return t.schema }
func (t *GameState) Changes() *statesync.ChangeSet { return t.changes }
func (t *GameState) ClearChanges()                 { t.changes.Clear() }
func (t *GameState) MarkAllDirty()                 { t.changes.MarkAll(4) }

func (t *GameState) GetFieldValue(index uint8) interface{} {
	t.mu.RLock()
	defer t.mu.RUnlock()
	switch index {
	case 0:
		return t.round
	case 1:
		return t.phase
	case 2:
		return t.players
	case 3:
		return t.scores
	case 4:
		return t.secretseed
	}
	return nil
}

// FastEncoder implementation - zero allocation encoding

func (t *GameState) EncodeChangesTo(e *statesync.Encoder) {
	t.mu.RLock()
	defer t.mu.RUnlock()

	// Count and write number of changes
	changes := t.changes
	count := 0
	if changes.IsFieldDirty(0) {
		count++
	}
	if changes.IsFieldDirty(1) {
		count++
	}
	if changes.IsFieldDirty(2) {
		count++
	}
	if changes.IsFieldDirty(3) {
		count++
	}
	if changes.IsFieldDirty(4) {
		count++
	}
	e.WriteChangeCount(count)

	// Encode each changed field directly (no interface{} boxing)
	if changes.IsFieldDirty(0) {
		e.WriteFieldHeader(0, statesync.OpReplace)
		e.WriteInt32(t.round)
	}
	if changes.IsFieldDirty(1) {
		e.WriteFieldHeader(1, statesync.OpReplace)
		e.WriteString(t.phase)
	}
	if changes.IsFieldDirty(2) {
		e.WriteFieldHeader(2, statesync.OpReplace)
		// Complex type - TODO: handle arrays/maps/structs
	}
	if changes.IsFieldDirty(3) {
		e.WriteFieldHeader(3, statesync.OpReplace)
		// Complex type - TODO: handle arrays/maps/structs
	}
	if changes.IsFieldDirty(4) {
		e.WriteFieldHeader(4, statesync.OpReplace)
		e.WriteInt64(t.secretseed)
	}
}

func (t *GameState) EncodeAllTo(e *statesync.Encoder) {
	t.mu.RLock()
	defer t.mu.RUnlock()

	// Encode all fields directly (no interface{} boxing)
	e.WriteInt32(t.round)
	e.WriteString(t.phase)
	// Complex type field Players - TODO: handle arrays/maps/structs
	// Complex type field Scores - TODO: handle arrays/maps/structs
	e.WriteInt64(t.secretseed)
}

// Getters and Setters

// Round returns the current value
func (t *GameState) Round() int32 {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.round
}

// SetRound sets the value and marks it as changed
func (t *GameState) SetRound(v int32) {
	t.mu.Lock()
	defer t.mu.Unlock()

	if t.round != v {
		t.round = v
		t.changes.Mark(0, statesync.OpReplace)
	}

}

// Phase returns the current value
func (t *GameState) Phase() string {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.phase
}

// SetPhase sets the value and marks it as changed
func (t *GameState) SetPhase(v string) {
	t.mu.Lock()
	defer t.mu.Unlock()

	if t.phase != v {
		t.phase = v
		t.changes.Mark(1, statesync.OpReplace)
	}

}

// Players returns the current value
func (t *GameState) Players() []Player {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.players
}

// SetPlayers replaces the entire slice
func (t *GameState) SetPlayers(v []Player) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.players = v
	t.changes.Mark(2, statesync.OpReplace)
}

// AppendPlayers adds an element to the slice
func (t *GameState) AppendPlayers(v Player) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.players = append(t.players, v)
	arr := t.changes.GetOrCreateArray(2)
	arr.MarkAdd(len(t.players)-1, v)
}

// RemovePlayersAt removes an element at index
func (t *GameState) RemovePlayersAt(index int) {
	t.mu.Lock()
	defer t.mu.Unlock()
	if index >= 0 && index < len(t.players) {
		t.players = append(t.players[:index], t.players[index+1:]...)
		arr := t.changes.GetOrCreateArray(2)
		arr.MarkRemove(index)
	}
}

// UpdatePlayersAt updates an element at index
func (t *GameState) UpdatePlayersAt(index int, v Player) {
	t.mu.Lock()
	defer t.mu.Unlock()
	if index >= 0 && index < len(t.players) {
		t.players[index] = v
		arr := t.changes.GetOrCreateArray(2)
		arr.MarkReplace(index, v)
	}
}

// PlayersLen returns the length of the slice
func (t *GameState) PlayersLen() int {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return len(t.players)
}

// PlayersAt returns the element at index
func (t *GameState) PlayersAt(index int) Player {
	t.mu.RLock()
	defer t.mu.RUnlock()
	if index >= 0 && index < len(t.players) {
		return t.players[index]
	}
	var zero Player
	return zero
}

// Scores returns the current value
func (t *GameState) Scores() map[string]int64 {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.scores
}

// SetScores replaces the entire map
func (t *GameState) SetScores(v map[string]int64) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.scores = v
	t.changes.Mark(3, statesync.OpReplace)
}

// SetScoresKey sets a map key
func (t *GameState) SetScoresKey(key string, v int64) {
	t.mu.Lock()
	defer t.mu.Unlock()
	if t.scores == nil {
		t.scores = make(map[string]int64)
	}
	_, existed := t.scores[key]
	t.scores[key] = v
	m := t.changes.GetOrCreateMap(3)
	if existed {
		m.MarkReplace(key, v)
	} else {
		m.MarkAdd(key, v)
	}
}

// DeleteScoresKey deletes a map key
func (t *GameState) DeleteScoresKey(key string) {
	t.mu.Lock()
	defer t.mu.Unlock()
	if t.scores != nil {
		if _, ok := t.scores[key]; ok {
			delete(t.scores, key)
			m := t.changes.GetOrCreateMap(3)
			m.MarkRemove(key)
		}
	}
}

// ScoresGet returns the value for a key
func (t *GameState) ScoresGet(key string) (int64, bool) {
	t.mu.RLock()
	defer t.mu.RUnlock()
	if t.scores == nil {
		var zero int64
		return zero, false
	}
	v, ok := t.scores[key]
	return v, ok
}

// SecretSeed returns the current value
func (t *GameState) SecretSeed() int64 {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.secretseed
}

// SetSecretSeed sets the value and marks it as changed
func (t *GameState) SetSecretSeed(v int64) {
	t.mu.Lock()
	defer t.mu.Unlock()

	if t.secretseed != v {
		t.secretseed = v
		t.changes.Mark(4, statesync.OpReplace)
	}

}
