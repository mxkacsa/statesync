package statesync

import (
	"testing"
)

// Test types for visibility
type VisTestPlayer struct {
	ID       string   `track:"0" identity:"true"`
	Team     string   `track:"1" teamKey:"true"`
	Name     string   `track:"2"`
	Hand     []string `track:"3" visible:"self"`
	Position int      `track:"4" visible:"team"`
	Health   int      `track:"5" visible:"self|team"`
	Secret   string   `track:"6" visible:"private"`
	MapData  []int    `track:"7" visible:"hasMap"`
}

// Generated code simulation (this would be generated by trackgen)

type VisTestPlayerVisibilityCtx struct {
	ViewerID   string
	ViewerTeam string
	HasMap     func(viewerID string) bool
}

func (s *VisTestPlayer) ShallowClone() *VisTestPlayer {
	clone := *s
	if s.Hand != nil {
		clone.Hand = make([]string, len(s.Hand))
		copy(clone.Hand, s.Hand)
	}
	if s.MapData != nil {
		clone.MapData = make([]int, len(s.MapData))
		copy(clone.MapData, s.MapData)
	}
	return &clone
}

func (s *VisTestPlayer) FilterFor(ctx *VisTestPlayerVisibilityCtx) *VisTestPlayer {
	if ctx == nil {
		return s
	}

	// Check if viewer is the owner - if so, return full state
	if s.ID == ctx.ViewerID {
		return s
	}

	filtered := s.ShallowClone()

	// Hand: visible:"self" - only visible to owner
	if s.ID != ctx.ViewerID {
		filtered.Hand = nil
	}

	// Position: visible:"team" - only visible to same team
	if ctx.ViewerTeam == "" || s.Team != ctx.ViewerTeam {
		filtered.Position = 0
	}

	// Health: visible:"self|team" - visible to owner or same team
	if s.ID != ctx.ViewerID && (ctx.ViewerTeam == "" || s.Team != ctx.ViewerTeam) {
		filtered.Health = 0
	}

	// Secret: visible:"private" - never visible to clients
	filtered.Secret = ""

	// MapData: visible:"hasMap" - custom predicate
	if ctx.HasMap == nil || !ctx.HasMap(ctx.ViewerID) {
		filtered.MapData = nil
	}

	return filtered
}

func FilterVisTestPlayerSliceFor(items []VisTestPlayer, ctx *VisTestPlayerVisibilityCtx) []VisTestPlayer {
	if ctx == nil || len(items) == 0 {
		return items
	}
	result := make([]VisTestPlayer, len(items))
	for i := range items {
		result[i] = *items[i].FilterFor(ctx)
	}
	return result
}

// ==================== OPTIMIZED VERSION ====================
// Key optimizations:
// 1. Value return instead of pointer - enables stack allocation
// 2. Conditional slice cloning - only clone if we'll keep the data
// 3. Pre-allocated output slice for batch operations

// FilterForOptimized returns filtered copy by value (stack-friendly)
// Only clones slices that will be kept, not ones that will be nil'd
func (s *VisTestPlayer) FilterForOptimized(ctx *VisTestPlayerVisibilityCtx) VisTestPlayer {
	// Nil context = return copy as-is
	if ctx == nil {
		return *s
	}

	// Self sees everything - return copy
	if s.ID == ctx.ViewerID {
		return *s
	}

	// Start with shallow copy (no slice allocation yet)
	filtered := *s

	// Determine what will be visible BEFORE cloning slices
	canSeeHand := false // self only, and we're not self
	canSeePosition := ctx.ViewerTeam != "" && s.Team == ctx.ViewerTeam
	canSeeHealth := canSeePosition // self|team, we're not self so just team
	canSeeMapData := ctx.HasMap != nil && ctx.HasMap(ctx.ViewerID)

	// Hand: visible:"self" - we're not self, so nil (no clone needed)
	if !canSeeHand {
		filtered.Hand = nil
	}

	// Position: visible:"team"
	if !canSeePosition {
		filtered.Position = 0
	}

	// Health: visible:"self|team"
	if !canSeeHealth {
		filtered.Health = 0
	}

	// Secret: visible:"private" - always hidden
	filtered.Secret = ""

	// MapData: visible:"hasMap" - only clone if visible
	if canSeeMapData && s.MapData != nil {
		filtered.MapData = make([]int, len(s.MapData))
		copy(filtered.MapData, s.MapData)
	} else {
		filtered.MapData = nil
	}

	return filtered
}

// FilterSliceOptimized filters into pre-allocated output slice
// Pass nil for out to allocate new slice
func FilterVisTestPlayerSliceOptimized(items []VisTestPlayer, ctx *VisTestPlayerVisibilityCtx, out []VisTestPlayer) []VisTestPlayer {
	if ctx == nil || len(items) == 0 {
		return items
	}

	// Reuse or allocate output slice
	if cap(out) >= len(items) {
		out = out[:len(items)]
	} else {
		out = make([]VisTestPlayer, len(items))
	}

	for i := range items {
		out[i] = items[i].FilterForOptimized(ctx)
	}
	return out
}

// ==================== ZERO-ALLOC VERSION ====================
// For maximum performance: modifies in place, caller must not need original

// FilterForInPlace modifies the player in place (zero allocation)
// WARNING: Destroys original data! Only use if you don't need the original.
func (s *VisTestPlayer) FilterForInPlace(ctx *VisTestPlayerVisibilityCtx) {
	if ctx == nil || s.ID == ctx.ViewerID {
		return
	}

	// Hand: visible:"self"
	s.Hand = nil

	// Position: visible:"team"
	if ctx.ViewerTeam == "" || s.Team != ctx.ViewerTeam {
		s.Position = 0
	}

	// Health: visible:"self|team"
	if ctx.ViewerTeam == "" || s.Team != ctx.ViewerTeam {
		s.Health = 0
	}

	// Secret: visible:"private"
	s.Secret = ""

	// MapData: visible:"hasMap"
	if ctx.HasMap == nil || !ctx.HasMap(ctx.ViewerID) {
		s.MapData = nil
	}
}

// Tests

func TestVisibility_SelfSeesAll(t *testing.T) {
	player := &VisTestPlayer{
		ID:       "alice",
		Team:     "red",
		Name:     "Alice",
		Hand:     []string{"ace", "king"},
		Position: 100,
		Health:   50,
		Secret:   "password123",
		MapData:  []int{1, 2, 3},
	}

	ctx := &VisTestPlayerVisibilityCtx{
		ViewerID:   "alice",
		ViewerTeam: "red",
	}

	filtered := player.FilterFor(ctx)

	// Self should see everything
	if filtered.Hand == nil || len(filtered.Hand) != 2 {
		t.Errorf("Self should see own Hand, got %v", filtered.Hand)
	}
	if filtered.Position != 100 {
		t.Errorf("Self should see own Position, got %d", filtered.Position)
	}
	if filtered.Health != 50 {
		t.Errorf("Self should see own Health, got %d", filtered.Health)
	}
	// Note: Secret is still visible to self with this implementation
	// because we return early when viewer == owner
}

func TestVisibility_OpponentHidesPrivate(t *testing.T) {
	player := &VisTestPlayer{
		ID:       "alice",
		Team:     "red",
		Name:     "Alice",
		Hand:     []string{"ace", "king"},
		Position: 100,
		Health:   50,
		Secret:   "password123",
		MapData:  []int{1, 2, 3},
	}

	ctx := &VisTestPlayerVisibilityCtx{
		ViewerID:   "bob",
		ViewerTeam: "blue",
	}

	filtered := player.FilterFor(ctx)

	// Opponent should NOT see Hand (self only)
	if filtered.Hand != nil {
		t.Errorf("Opponent should NOT see Hand, got %v", filtered.Hand)
	}

	// Opponent should NOT see Position (team only)
	if filtered.Position != 0 {
		t.Errorf("Opponent should NOT see Position, got %d", filtered.Position)
	}

	// Opponent should NOT see Health (self|team)
	if filtered.Health != 0 {
		t.Errorf("Opponent should NOT see Health, got %d", filtered.Health)
	}

	// Opponent should NOT see Secret (private)
	if filtered.Secret != "" {
		t.Errorf("Opponent should NOT see Secret, got %s", filtered.Secret)
	}

	// Opponent should NOT see MapData (no hasMap predicate)
	if filtered.MapData != nil {
		t.Errorf("Opponent should NOT see MapData, got %v", filtered.MapData)
	}

	// But Name should still be visible (public)
	if filtered.Name != "Alice" {
		t.Errorf("Opponent should see Name, got %s", filtered.Name)
	}
}

func TestVisibility_TeamSeesTeamFields(t *testing.T) {
	player := &VisTestPlayer{
		ID:       "alice",
		Team:     "red",
		Name:     "Alice",
		Hand:     []string{"ace", "king"},
		Position: 100,
		Health:   50,
		Secret:   "password123",
	}

	ctx := &VisTestPlayerVisibilityCtx{
		ViewerID:   "charlie", // Different player
		ViewerTeam: "red",     // Same team
	}

	filtered := player.FilterFor(ctx)

	// Teammate should NOT see Hand (self only)
	if filtered.Hand != nil {
		t.Errorf("Teammate should NOT see Hand, got %v", filtered.Hand)
	}

	// Teammate SHOULD see Position (team)
	if filtered.Position != 100 {
		t.Errorf("Teammate should see Position, got %d", filtered.Position)
	}

	// Teammate SHOULD see Health (self|team)
	if filtered.Health != 50 {
		t.Errorf("Teammate should see Health, got %d", filtered.Health)
	}

	// Teammate should NOT see Secret (private)
	if filtered.Secret != "" {
		t.Errorf("Teammate should NOT see Secret, got %s", filtered.Secret)
	}
}

func TestVisibility_CustomPredicate(t *testing.T) {
	player := &VisTestPlayer{
		ID:      "alice",
		Team:    "red",
		MapData: []int{1, 2, 3},
	}

	// Viewer without map
	ctxNoMap := &VisTestPlayerVisibilityCtx{
		ViewerID:   "bob",
		ViewerTeam: "blue",
		HasMap:     func(viewerID string) bool { return false },
	}

	filtered := player.FilterFor(ctxNoMap)
	if filtered.MapData != nil {
		t.Errorf("Viewer without map should NOT see MapData, got %v", filtered.MapData)
	}

	// Viewer with map
	ctxWithMap := &VisTestPlayerVisibilityCtx{
		ViewerID:   "bob",
		ViewerTeam: "blue",
		HasMap:     func(viewerID string) bool { return true },
	}

	filtered = player.FilterFor(ctxWithMap)
	if filtered.MapData == nil || len(filtered.MapData) != 3 {
		t.Errorf("Viewer with map SHOULD see MapData, got %v", filtered.MapData)
	}
}

func TestVisibility_FilterSlice(t *testing.T) {
	players := []VisTestPlayer{
		{ID: "alice", Team: "red", Name: "Alice", Hand: []string{"ace"}, Health: 100},
		{ID: "bob", Team: "blue", Name: "Bob", Hand: []string{"king"}, Health: 80},
		{ID: "charlie", Team: "red", Name: "Charlie", Hand: []string{"queen"}, Health: 60},
	}

	ctx := &VisTestPlayerVisibilityCtx{
		ViewerID:   "alice",
		ViewerTeam: "red",
	}

	filtered := FilterVisTestPlayerSliceFor(players, ctx)

	// Alice (self) - sees everything
	if filtered[0].Hand == nil || len(filtered[0].Hand) != 1 {
		t.Errorf("Alice should see own hand, got %v", filtered[0].Hand)
	}
	if filtered[0].Health != 100 {
		t.Errorf("Alice should see own health, got %d", filtered[0].Health)
	}

	// Bob (opponent) - sees nothing private
	if filtered[1].Hand != nil {
		t.Errorf("Alice should NOT see Bob's hand, got %v", filtered[1].Hand)
	}
	if filtered[1].Health != 0 {
		t.Errorf("Alice should NOT see Bob's health, got %d", filtered[1].Health)
	}

	// Charlie (teammate) - sees team fields
	if filtered[2].Hand != nil {
		t.Errorf("Alice should NOT see Charlie's hand, got %v", filtered[2].Hand)
	}
	if filtered[2].Health != 60 {
		t.Errorf("Alice SHOULD see Charlie's health (teammate), got %d", filtered[2].Health)
	}
}

func TestVisibility_NilContext(t *testing.T) {
	player := &VisTestPlayer{
		ID:   "alice",
		Hand: []string{"ace"},
	}

	// Nil context should return original (no filtering)
	filtered := player.FilterFor(nil)
	if filtered != player {
		t.Errorf("Nil context should return original player")
	}
}

func TestVisibility_ShallowClone(t *testing.T) {
	player := &VisTestPlayer{
		ID:   "alice",
		Hand: []string{"ace", "king"},
	}

	clone := player.ShallowClone()

	// Modify clone's hand
	clone.Hand[0] = "modified"

	// Original should be unchanged
	if player.Hand[0] != "ace" {
		t.Errorf("ShallowClone should create independent slice copy, original was modified")
	}
}

func BenchmarkVisibility_FilterFor(b *testing.B) {
	player := &VisTestPlayer{
		ID:       "alice",
		Team:     "red",
		Name:     "Alice",
		Hand:     []string{"ace", "king", "queen", "jack", "ten"},
		Position: 100,
		Health:   50,
		Secret:   "password123",
		MapData:  []int{1, 2, 3, 4, 5},
	}

	ctx := &VisTestPlayerVisibilityCtx{
		ViewerID:   "bob",
		ViewerTeam: "blue",
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = player.FilterFor(ctx)
	}
}

func BenchmarkVisibility_FilterSlice100(b *testing.B) {
	players := make([]VisTestPlayer, 100)
	for i := range players {
		players[i] = VisTestPlayer{
			ID:       "player" + string(rune('0'+i%10)),
			Team:     "team" + string(rune('0'+i%4)),
			Name:     "Player",
			Hand:     []string{"ace", "king"},
			Position: i,
			Health:   100,
		}
	}

	ctx := &VisTestPlayerVisibilityCtx{
		ViewerID:   "player0",
		ViewerTeam: "team0",
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = FilterVisTestPlayerSliceFor(players, ctx)
	}
}

// ==================== OPTIMIZED BENCHMARKS ====================

func BenchmarkVisibility_FilterForOptimized(b *testing.B) {
	player := &VisTestPlayer{
		ID:       "alice",
		Team:     "red",
		Name:     "Alice",
		Hand:     []string{"ace", "king", "queen", "jack", "ten"},
		Position: 100,
		Health:   50,
		Secret:   "password123",
		MapData:  []int{1, 2, 3, 4, 5},
	}

	ctx := &VisTestPlayerVisibilityCtx{
		ViewerID:   "bob",
		ViewerTeam: "blue",
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = player.FilterForOptimized(ctx)
	}
}

func BenchmarkVisibility_FilterSlice100Optimized(b *testing.B) {
	players := make([]VisTestPlayer, 100)
	for i := range players {
		players[i] = VisTestPlayer{
			ID:       "player" + string(rune('0'+i%10)),
			Team:     "team" + string(rune('0'+i%4)),
			Name:     "Player",
			Hand:     []string{"ace", "king"},
			Position: i,
			Health:   100,
		}
	}

	ctx := &VisTestPlayerVisibilityCtx{
		ViewerID:   "player0",
		ViewerTeam: "team0",
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = FilterVisTestPlayerSliceOptimized(players, ctx, nil)
	}
}

func BenchmarkVisibility_FilterSlice100OptimizedReuse(b *testing.B) {
	players := make([]VisTestPlayer, 100)
	for i := range players {
		players[i] = VisTestPlayer{
			ID:       "player" + string(rune('0'+i%10)),
			Team:     "team" + string(rune('0'+i%4)),
			Name:     "Player",
			Hand:     []string{"ace", "king"},
			Position: i,
			Health:   100,
		}
	}

	ctx := &VisTestPlayerVisibilityCtx{
		ViewerID:   "player0",
		ViewerTeam: "team0",
	}

	// Pre-allocate output buffer
	out := make([]VisTestPlayer, 100)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = FilterVisTestPlayerSliceOptimized(players, ctx, out)
	}
}

func BenchmarkVisibility_FilterForInPlace(b *testing.B) {
	ctx := &VisTestPlayerVisibilityCtx{
		ViewerID:   "bob",
		ViewerTeam: "blue",
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		// Create fresh player each iteration (simulates real use)
		player := VisTestPlayer{
			ID:       "alice",
			Team:     "red",
			Name:     "Alice",
			Hand:     []string{"ace", "king", "queen", "jack", "ten"},
			Position: 100,
			Health:   50,
			Secret:   "password123",
			MapData:  []int{1, 2, 3, 4, 5},
		}
		player.FilterForInPlace(ctx)
	}
}

// Benchmark self-view (should be fastest - early return)
func BenchmarkVisibility_FilterForSelf(b *testing.B) {
	player := &VisTestPlayer{
		ID:       "alice",
		Team:     "red",
		Name:     "Alice",
		Hand:     []string{"ace", "king", "queen", "jack", "ten"},
		Position: 100,
		Health:   50,
		Secret:   "password123",
		MapData:  []int{1, 2, 3, 4, 5},
	}

	ctx := &VisTestPlayerVisibilityCtx{
		ViewerID:   "alice", // Self!
		ViewerTeam: "red",
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = player.FilterFor(ctx)
	}
}
